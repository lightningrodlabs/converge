var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CellMap_cellMap;
import { decodeHashFromBase64, encodeHashToBase64, } from "@holochain/client";
import flatMap from "lodash-es/flatMap.js";
export class HoloHashMap {
    constructor(initialEntries) {
        this._map = new Map();
        if (initialEntries) {
            for (const [key, value] of initialEntries) {
                this.set(key, value);
            }
        }
    }
    has(key) {
        return this._map.has(encodeHashToBase64(key));
    }
    get(key) {
        return this._map.get(encodeHashToBase64(key));
    }
    set(key, value) {
        this._map.set(encodeHashToBase64(key), value);
        return this;
    }
    delete(key) {
        return this._map.delete(encodeHashToBase64(key));
    }
    keys() {
        return Array.from(this._map.keys())
            .map((h) => decodeHashFromBase64(h))[Symbol.iterator]();
    }
    values() {
        return this._map.values();
    }
    entries() {
        return Array.from(this._map.entries())
            .map(([h, v]) => [decodeHashFromBase64(h), v])[Symbol.iterator]();
    }
    clear() {
        return this._map.clear();
    }
    forEach(callbackfn, thisArg) {
        return this._map.forEach((value, key) => {
            callbackfn(value, decodeHashFromBase64(key), this);
        }, thisArg);
    }
    get size() {
        return this._map.size;
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    get [Symbol.toStringTag]() {
        return this._map[Symbol.toStringTag];
    }
}
export class EntryHashMap extends HoloHashMap {
}
export class ActionHashMap extends HoloHashMap {
}
export class AgentPubKeyMap extends HoloHashMap {
}
export class DnaHashMap extends HoloHashMap {
}
export class CellMap {
    constructor(initialEntries) {
        // Segmented by DnaHash / AgentPubKey
        _CellMap_cellMap.set(this, new HoloHashMap());
        if (initialEntries) {
            for (const [cellId, value] of initialEntries) {
                this.set(cellId, value);
            }
        }
    }
    get([dnaHash, agentPubKey]) {
        return __classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash)
            ? __classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash).get(agentPubKey)
            : undefined;
    }
    has(cellId) {
        return !!this.get(cellId);
    }
    valuesForDna(dnaHash) {
        const dnaMap = __classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash);
        return dnaMap ? Array.from(dnaMap.values()) : [];
    }
    agentsForDna(dnaHash) {
        const dnaMap = __classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash);
        return dnaMap ? Array.from(dnaMap.keys()) : [];
    }
    set([dnaHash, agentPubKey], value) {
        if (!__classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash))
            __classPrivateFieldGet(this, _CellMap_cellMap, "f").set(dnaHash, new HoloHashMap());
        __classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash).set(agentPubKey, value);
    }
    delete([dnaHash, agentPubKey]) {
        if (__classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash)) {
            __classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash).delete(agentPubKey);
            if (Array.from(__classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash).keys()).length === 0) {
                __classPrivateFieldGet(this, _CellMap_cellMap, "f").delete(dnaHash);
            }
        }
    }
    entries() {
        return this.cellIds().map((cellId) => [cellId, this.get(cellId)]);
    }
    filter(fn) {
        const entries = this.entries();
        const mappedValues = entries.filter(([id, v]) => fn(v));
        return new CellMap(mappedValues);
    }
    map(fn) {
        const entries = this.entries();
        const mappedValues = entries.map(([id, v]) => [id, fn(v)]);
        return new CellMap(mappedValues);
    }
    values() {
        return this.cellIds().map((cellId) => this.get(cellId));
    }
    cellIds() {
        const dnaHashes = Array.from(__classPrivateFieldGet(this, _CellMap_cellMap, "f").keys());
        return flatMap(dnaHashes, (dnaHash) => Array.from(__classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash).keys()).map((agentPubKey) => [dnaHash, agentPubKey]));
    }
}
_CellMap_cellMap = new WeakMap();
export class LazyMap {
    constructor(newValue) {
        this.newValue = newValue;
        this.map = new Map();
    }
    get(hash) {
        if (!this.map.has(hash)) {
            this.map.set(hash, this.newValue(hash));
        }
        return this.map.get(hash);
    }
}
export class LazyHoloHashMap {
    constructor(newValue) {
        this.newValue = newValue;
        this.map = new HoloHashMap();
    }
    get(hash) {
        if (!this.map.has(hash)) {
            this.map.set(hash, this.newValue(hash));
        }
        return this.map.get(hash);
    }
}
//# sourceMappingURL=holo-hash-map.js.map