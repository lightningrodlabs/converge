import uniqWith from "lodash-es/uniqWith.js";
import isEqual from "lodash-es/isEqual.js";
import { ActionHashMap, AgentPubKeyMap, EntryHashMap, } from "./holo-hash-map.js";
import { EntryRecord } from "./entry-record.js";
import { mapValues } from "./map-utils.js";
export class RecordBag {
    get entriesByAuthor() {
        const temp = mapValues(this.authorMap, (actionHashes) => actionHashes.map((hash) => this.actionMap.get(hash)));
        return mapValues(temp, (actions) => actions
            .map((action) => this.entryMap.get(action.entry_hash))
            .filter((entry) => entry !== undefined));
    }
    get entryRecords() {
        return this.records.map((r) => new EntryRecord(r));
    }
    entryRecord(actionHash) {
        const record = this.records.find((r) => isEqual(r.signed_action.hashed.hash, actionHash));
        return record ? new EntryRecord(record) : undefined;
    }
    constructor(records = []) {
        this.records = records;
        // Map of entry hash -> entry, already decoded
        this.entryMap = new EntryHashMap();
        // Map of action hash -> action
        // Timestamp is in milliseconds
        this.actionMap = new ActionHashMap();
        // Map of entry hash -> all the actions that have created or updated to that entry
        this.entryActions = new EntryHashMap();
        // For each agent, contains all the actions it has authored
        this.authorMap = new AgentPubKeyMap();
        // For each action, all the actions that update it
        this.updates = new ActionHashMap();
        // For each action, all the actions that delete it
        this.deletes = new ActionHashMap();
        this.add(records);
    }
    add(records) {
        this.records = this.records.concat(records);
        for (const record of records) {
            const entryRecord = new EntryRecord(record);
            if (entryRecord.entryHash) {
                this.entryMap.set(entryRecord.entryHash, entryRecord.entry);
                if (!this.entryActions.has(entryRecord.entryHash)) {
                    this.entryActions.set(entryRecord.entryHash, []);
                }
                this.entryActions.set(entryRecord.entryHash, uniqWith([
                    ...this.entryActions.get(entryRecord.entryHash),
                    entryRecord.actionHash,
                ], isEqual));
            }
            this.actionMap.set(entryRecord.actionHash, entryRecord.action);
            if (!this.authorMap.has(entryRecord.action.author)) {
                this.authorMap.set(entryRecord.action.author, []);
            }
            this.authorMap.set(entryRecord.action.author, uniqWith([
                ...this.authorMap.get(entryRecord.action.author),
                entryRecord.actionHash,
            ], isEqual));
            if (entryRecord.action.original_action_address) {
                const originalActionAddress = entryRecord.action
                    .original_action_address;
                const currentUpdates = this.updates.get(originalActionAddress);
                this.updates.set(originalActionAddress, uniqWith([...currentUpdates, entryRecord.actionHash], isEqual));
            }
            if (entryRecord.action.deletes_address) {
                const originalActionAddress = entryRecord.action
                    .deletes_address;
                const currentDeletes = this.deletes.get(originalActionAddress);
                this.deletes.set(originalActionAddress, uniqWith([...currentDeletes, entryRecord.actionHash], isEqual));
            }
        }
    }
    addBag(recordBag) {
        this.add(recordBag.records);
    }
}
//# sourceMappingURL=record-bag.js.map