import * as ed25519 from "@noble/ed25519";
import { encodeHashToBase64 } from "../utils/base64.js";
if (!globalThis.crypto) {
    import("node:crypto").then((webcrypto) => (globalThis.crypto = webcrypto));
}
const signingCredentials = new Map();
/**
 * Get credentials for signing zome calls.
 *
 * @param cellId - Cell id to get credentials of.
 * @returns The keys and cap secret required for signing a zome call.
 *
 * @public
 */
export const getSigningCredentials = (cellId) => {
    const cellIdB64 = encodeHashToBase64(cellId[0]).concat(encodeHashToBase64(cellId[1]));
    return signingCredentials.get(cellIdB64);
};
/**
 * Set credentials for signing zome calls.
 *
 * @param cellId - Cell id to set credentials for.
 *
 * @public
 */
export const setSigningCredentials = (cellId, credentials) => {
    const cellIdB64 = encodeHashToBase64(cellId[0]).concat(encodeHashToBase64(cellId[1]));
    signingCredentials.set(cellIdB64, credentials);
};
/**
 * Generates a key pair for signing zome calls.
 *
 * @returns The signing key pair and an agent pub key based on the public key.
 *
 * @public
 */
export const generateSigningKeyPair = async () => {
    const privateKey = ed25519.utils.randomPrivateKey();
    const publicKey = await ed25519.getPublicKeyAsync(privateKey);
    const keyPair = { privateKey, publicKey };
    const signingKey = new Uint8Array([132, 32, 36].concat(...publicKey).concat(...[0, 0, 0, 0]));
    return [keyPair, signingKey];
};
/**
 * @public
 */
export const randomCapSecret = () => randomByteArray(64);
/**
 * @public
 */
export const randomNonce = () => randomByteArray(32);
/**
 * @public
 */
export const randomByteArray = (length) => globalThis.crypto.getRandomValues(new Uint8Array(length));
/**
 * @public
 */
export const getNonceExpiration = () => (Date.now() + 5 * 60 * 1000) * 1000; // 5 mins from now in microseconds
