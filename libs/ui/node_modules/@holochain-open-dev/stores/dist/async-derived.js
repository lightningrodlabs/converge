import { derived } from "svelte/store";
const isPromise = (v) => typeof v === "object" && typeof v.then === "function";
export function asyncDerived(store, derive) {
    return derived(store, (value, set) => {
        if (value.status === "error")
            set(value);
        else if (value.status === "pending")
            set(value);
        else {
            const v = derive(value.value);
            if (isPromise(v)) {
                set({ status: "pending" });
                Promise.resolve(v)
                    .then((v) => {
                    set({
                        status: "complete",
                        value: v,
                    });
                })
                    .catch((error) => {
                    set({
                        status: "error",
                        error,
                    });
                });
            }
            else {
                set({
                    status: "complete",
                    value: v,
                });
            }
        }
    });
}
// Joins all the given `AsyncReadables` into a single `AsyncReadable`
export function join(stores) {
    return derived(stores, (values) => {
        const firstError = values.find((v) => v && v.status === "error");
        if (firstError) {
            return firstError;
        }
        const firstLoading = values.find((v) => v && v.status === "pending");
        if (firstLoading) {
            return firstLoading;
        }
        const v = values.map((v) => {
            if (v && v.status === "complete")
                return v.value;
            return v;
        });
        return {
            status: "complete",
            value: v,
        };
    });
}
export function deriveStore(store, deriveStoreFn) {
    return derived(store, (value, set) => deriveStoreFn(value).subscribe(set));
}
export function asyncDeriveStore(store, deriveStoreFn) {
    return derived(store, (value, set) => {
        if (value.status === "error")
            set(value);
        else if (value.status === "pending")
            set(value);
        else {
            const v = deriveStoreFn(value.value);
            if (isPromise(v)) {
                let unsubscribe;
                set({ status: "pending" });
                Promise.resolve(v)
                    .then((v) => {
                    unsubscribe = v.subscribe(set);
                })
                    .catch((error) => {
                    set({
                        status: "error",
                        error,
                    });
                });
                return () => {
                    if (unsubscribe)
                        unsubscribe();
                };
            }
            else {
                return v.subscribe((v) => {
                    set(v);
                });
            }
        }
        return undefined;
    });
}
// Derives the given store, and returns the value of the original joined with the derived value
export function asyncDeriveAndJoin(store, fn) {
    return asyncDeriveStore(store, (v) => asyncDerived(fn(v), (u) => [v, u]));
}
//# sourceMappingURL=async-derived.js.map