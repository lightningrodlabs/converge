{
  "version": 3,
  "sources": ["../../../../node_modules/@lit-labs/context/src/lib/value-notifier.ts", "../../../../node_modules/@lit-labs/context/src/lib/controllers/context-provider.ts", "../../../../node_modules/@lit-labs/context/src/lib/decorators/provide.ts", "../../../../node_modules/@lit-labs/context/src/lib/context-request-event.ts", "../../../../node_modules/@lit-labs/context/src/lib/controllers/context-consumer.ts", "../../../../node_modules/@lit-labs/context/src/lib/decorators/consume.ts", "../../../../node_modules/@lit-labs/context/src/lib/create-context.ts", "../../@holochain-open-dev/profiles/src/context.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextCallback} from './context-request-event.js';\n\n/**\n * A disposer function\n */\ntype Disposer = () => void;\n\n/**\n * A simple class which stores a value, and triggers registered callbacks when the\n * value is changed via its setter.\n *\n * An implementor might use other observable patterns such as MobX or Redux to get\n * behavior like this. But this is a pretty minimal approach that will likely work\n * for a number of use cases.\n */\nexport class ValueNotifier<T> {\n  private callbacks: Map<ContextCallback<T>, Disposer> = new Map();\n\n  private _value!: T;\n  public get value(): T {\n    return this._value;\n  }\n  public set value(v: T) {\n    this.setValue(v);\n  }\n\n  public setValue(v: T, force = false) {\n    const update = force || !Object.is(v, this._value);\n    this._value = v;\n    if (update) {\n      this.updateObservers();\n    }\n  }\n\n  constructor(defaultValue?: T) {\n    if (defaultValue !== undefined) {\n      this.value = defaultValue;\n    }\n  }\n\n  updateObservers = (): void => {\n    for (const [callback, disposer] of this.callbacks) {\n      callback(this._value, disposer);\n    }\n  };\n\n  addCallback(callback: ContextCallback<T>, subscribe?: boolean): void {\n    if (subscribe) {\n      if (!this.callbacks.has(callback)) {\n        this.callbacks.set(callback, () => {\n          this.callbacks.delete(callback);\n        });\n      }\n    }\n    callback(this.value);\n  }\n\n  clearCallbacks(): void {\n    this.callbacks.clear();\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextRequestEvent} from '../context-request-event.js';\nimport {Context, ContextType} from '../create-context.js';\nimport {ValueNotifier} from '../value-notifier.js';\nimport {ReactiveController, ReactiveElement} from 'lit';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    /**\n     * A 'context-provider' event can be emitted by any element which hosts\n     * a context provider to indicate it is available for use.\n     */\n    'context-provider': ContextProviderEvent<Context<unknown, unknown>>;\n  }\n}\n\nexport class ContextProviderEvent<\n  C extends Context<unknown, unknown>\n> extends Event {\n  /**\n   *\n   * @param context the context which this provider can provide\n   */\n  public constructor(public readonly context: C) {\n    super('context-provider', {bubbles: true, composed: true});\n  }\n}\n\n/**\n * A ReactiveController which can add context provider behavior to a\n * custom-element.\n *\n * This controller simply listens to the `context-request` event when\n * the host is connected to the DOM and registers the received callbacks\n * against its observable Context implementation.\n */\nexport class ContextProvider<T extends Context<unknown, unknown>>\n  extends ValueNotifier<ContextType<T>>\n  implements ReactiveController\n{\n  constructor(\n    protected host: ReactiveElement,\n    private context: T,\n    initialValue?: ContextType<T>\n  ) {\n    super(initialValue);\n    this.attachListeners();\n    this.host.addController(this);\n  }\n\n  public onContextRequest = (\n    ev: ContextRequestEvent<Context<unknown, unknown>>\n  ): void => {\n    // Only call the callback if the context matches.\n    // Also, in case an element is a consumer AND a provider\n    // of the same context, we want to avoid the element to self-register.\n    // The check on composedPath (as opposed to ev.target) is to cover cases\n    // where the consumer is in the shadowDom of the provider (in which case,\n    // event.target === this.host because of event retargeting).\n    if (ev.context !== this.context || ev.composedPath()[0] === this.host) {\n      return;\n    }\n    ev.stopPropagation();\n    this.addCallback(ev.callback, ev.subscribe);\n  };\n\n  private attachListeners() {\n    this.host.addEventListener('context-request', this.onContextRequest);\n  }\n\n  hostConnected(): void {\n    // emit an event to signal a provider is available for this context\n    this.host.dispatchEvent(new ContextProviderEvent(this.context));\n  }\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ReactiveElement} from '@lit/reactive-element';\nimport {decorateProperty} from '@lit/reactive-element/decorators/base.js';\nimport {Context} from '../create-context.js';\nimport {ContextProvider} from '../controllers/context-provider.js';\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\n/**\n * A property decorator that adds a ContextConsumer controller to the component\n * which will try and retrieve a value for the property via the Context API.\n *\n * @param context A Context identifier value created via `createContext`\n * @param multiple An optional boolean which when true allows the value to be updated\n *   multiple times.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\n *\n * @example\n *\n * ```ts\n * import {consume} from '@lit-labs/context';\n * import {loggerContext} from 'community-protocols/logger';\n *\n * class MyElement {\n *   @provide(loggerContext)\n *   logger;\n *\n *   doThing() {\n *     this.logger.log('thing was done');\n *   }\n * }\n * ```\n * @category Decorator\n */\nexport function provide<ValueType>({\n  context: context,\n}: {\n  context: Context<unknown, ValueType>;\n}): <K extends PropertyKey>(\n  protoOrDescriptor: ReactiveElement & Record<K, ValueType>,\n  name?: K\n  // Note TypeScript requires the return type to be `void|any`\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n) => void | any {\n  return decorateProperty({\n    finisher: (ctor: typeof ReactiveElement, name: PropertyKey) => {\n      const controllerMap = new WeakMap();\n      ctor.addInitializer((element: ReactiveElement): void => {\n        controllerMap.set(element, new ContextProvider(element, context));\n      });\n      // proxy any existing setter for this property and use it to\n      // notify the controller of an updated value\n      const descriptor = Object.getOwnPropertyDescriptor(ctor.prototype, name);\n      const oldSetter = descriptor?.set;\n      const newDescriptor = {\n        ...descriptor,\n        set: function (value: ValueType) {\n          controllerMap.get(this)?.setValue(value);\n          if (oldSetter) {\n            oldSetter.call(this, value);\n          }\n        },\n      };\n      Object.defineProperty(ctor.prototype, name, newDescriptor);\n    },\n  });\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextType, Context} from './create-context.js';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    /**\n     * A 'context-request' event can be emitted by any element which desires\n     * a context value to be injected by an external provider.\n     */\n    'context-request': ContextRequestEvent<Context<unknown, unknown>>;\n  }\n}\n\n/**\n * A callback which is provided by a context requester and is called with the value satisfying the request.\n * This callback can be called multiple times by context providers as the requested value is changed.\n */\nexport type ContextCallback<ValueType> = (\n  value: ValueType,\n  unsubscribe?: () => void\n) => void;\n\n/**\n * Interface definition for a ContextRequest\n */\nexport interface ContextRequest<C extends Context<unknown, unknown>> {\n  readonly context: C;\n  readonly callback: ContextCallback<ContextType<C>>;\n  readonly subscribe?: boolean;\n}\n\n/**\n * An event fired by a context requester to signal it desires a specified context with the given key.\n *\n * A provider should inspect the `context` property of the event to determine if it has a value that can\n * satisfy the request, calling the `callback` with the requested value if so.\n *\n * If the requested context event contains a truthy `subscribe` value, then a provider can call the callback\n * multiple times if the value is changed, if this is the case the provider should pass an `unsubscribe`\n * method to the callback which consumers can invoke to indicate they no longer wish to receive these updates.\n *\n * If no `subscribe` value is present in the event, then the provider can assume that this is a 'one time'\n * request for the context and can therefore not track the consumer.\n */\nexport class ContextRequestEvent<C extends Context<unknown, unknown>>\n  extends Event\n  implements ContextRequest<C>\n{\n  /**\n   *\n   * @param context the context key to request\n   * @param callback the callback that should be invoked when the context with the specified key is available\n   * @param subscribe an optional argument, if true indicates we want to subscribe to future updates\n   */\n  public constructor(\n    public readonly context: C,\n    public readonly callback: ContextCallback<ContextType<C>>,\n    public readonly subscribe?: boolean\n  ) {\n    super('context-request', {bubbles: true, composed: true});\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextRequestEvent} from '../context-request-event.js';\nimport {Context, ContextType} from '../create-context.js';\nimport {ReactiveController, ReactiveElement} from 'lit';\n\n/**\n * ContextConsumer is a ReactiveController which binds a custom-element's\n * lifecycle to the Context API. When an element is connected to the DOM it\n * will emit the context-request event, invoking the callback set on the\n * controller when the context request is satisfied. It will also call\n * the dispose method provided by the Context API when the element is\n * disconnected.\n */\nexport class ContextConsumer<\n  C extends Context<unknown, unknown>,\n  HostElement extends ReactiveElement\n> implements ReactiveController\n{\n  private provided = false;\n\n  public value?: ContextType<C> = undefined;\n\n  constructor(\n    protected host: HostElement,\n    private context: C,\n    private callback?: (value: ContextType<C>, dispose?: () => void) => void,\n    private subscribe: boolean = false\n  ) {\n    this.host.addController(this);\n  }\n\n  private unsubscribe?: () => void;\n\n  hostConnected(): void {\n    this.dispatchRequest();\n  }\n  hostDisconnected(): void {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n      this.unsubscribe = undefined;\n    }\n  }\n\n  private dispatchRequest() {\n    this.host.dispatchEvent(\n      new ContextRequestEvent(\n        this.context,\n        (value, unsubscribe) => {\n          // some providers will pass an unsubscribe function indicating they may provide future values\n          if (this.unsubscribe) {\n            // if the unsubscribe function changes this implies we have changed provider\n            if (this.unsubscribe !== unsubscribe) {\n              // cleanup the old provider\n              this.provided = false;\n              this.unsubscribe();\n            }\n            // if we don't support subscription, immediately unsubscribe\n            if (!this.subscribe) {\n              this.unsubscribe();\n            }\n          }\n\n          // store the value so that it can be retrieved from the controller\n          this.value = value;\n          // schedule an update in case this value is used in a template\n          this.host.requestUpdate();\n\n          // only invoke callback if we are either expecting updates or have not yet\n          // been provided a value\n          if (!this.provided || this.subscribe) {\n            this.provided = true;\n            if (this.callback) {\n              this.callback(value, unsubscribe);\n            }\n          }\n\n          this.unsubscribe = unsubscribe;\n        },\n        this.subscribe\n      )\n    );\n  }\n}\n", "/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ReactiveElement} from '@lit/reactive-element';\nimport {decorateProperty} from '@lit/reactive-element/decorators/base.js';\nimport {ContextConsumer} from '../controllers/context-consumer.js';\nimport {Context} from '../create-context.js';\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\n\n/**\n * A property decorator that adds a ContextConsumer controller to the component\n * which will try and retrieve a value for the property via the Context API.\n *\n * @param context A Context identifier value created via `createContext`\n * @param subscribe An optional boolean which when true allows the value to be updated\n *   multiple times.\n *\n * @example\n *\n * ```ts\n * import {consume} from '@lit-labs/context';\n * import {loggerContext, Logger} from 'community-protocols/logger';\n *\n * class MyElement {\n *   @consume({context: loggerContext})\n *   logger?: Logger;\n *\n *   doThing() {\n *     this.logger!.log('thing was done');\n *   }\n * }\n * ```\n * @category Decorator\n */\nexport function consume<ValueType>({\n  context: context,\n  subscribe,\n}: {\n  context: Context<unknown, ValueType>;\n  subscribe?: boolean;\n}): <K extends PropertyKey>(\n  // Partial<> allows for providing the value to an optional field\n  protoOrDescriptor: ReactiveElement & Partial<Record<K, ValueType>>,\n  name?: K\n  // Note TypeScript requires the return type to be `void|any`\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n) => void | any {\n  return decorateProperty({\n    finisher: (ctor: typeof ReactiveElement, name: PropertyKey) => {\n      ctor.addInitializer((element: ReactiveElement): void => {\n        new ContextConsumer(\n          element,\n          context,\n          (value: ValueType) => {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any -- have to force the property on the type\n            (element as any)[name] = value;\n          },\n          subscribe\n        );\n      });\n    },\n  });\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * The Context type defines a type brand to associate a key value with the context value type\n */\nexport type Context<KeyType, ValueType> = KeyType & {__context__: ValueType};\n\n/**\n * @deprecated use Context instead\n */\nexport type ContextKey<KeyType, ValueType> = Context<KeyType, ValueType>;\n\n/**\n * A helper type which can extract a Context value type from a Context type\n */\nexport type ContextType<Key extends Context<unknown, unknown>> =\n  Key extends Context<unknown, infer ValueType> ? ValueType : never;\n\n/**\n * Creates a typed Context.\n *\n * Contexts are compared with with strict equality.\n *\n * If you want two separate `createContext()` calls to referer to the same\n * context, then use a key that will by equal under strict equality like a\n * string for `Symbol.for()`:\n *\n * ```ts\n * // true\n * createContext('my-context') === createContext('my-context')\n * // true\n * createContext(Symbol.for('my-context')) === createContext(Symbol.for('my-context'))\n * ```\n *\n * If you want a context to be unique so that it's guaranteed to not collide\n * with other contexts, use a key that's unique under strict equality, like\n * a `Symbol()` or object.:\n *\n * ```\n * // false\n * createContext({}) === createContext({})\n * // false\n * createContext(Symbol('my-context')) === createContext(Symbol('my-context'))\n * ```\n *\n * @param key a context key value\n * @template ValueType the type of value that can be provided by this context.\n * @returns the context key value with the correct type\n */\nexport function createContext<ValueType>(key: unknown) {\n  return key as Context<typeof key, ValueType>;\n}\n", "import { createContext } from '@lit-labs/context';\nimport { ProfilesStore } from './profiles-store';\n\nexport const profilesStoreContext = createContext<ProfilesStore>(\n  'hc_zome_profiles/store'\n);\n"],
  "mappings": "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",
  "names": []
}
