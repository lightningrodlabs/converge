import {
  gBase64,
  isEqual_default
} from "./chunk-2AWGVYMQ.js";
import {
  decode
} from "./chunk-ZPGR2TPQ.js";
import {
  derived,
  readable,
  writable
} from "./chunk-IGAVQDRX.js";
import {
  get_store_value
} from "./chunk-PDNTOHOW.js";
import {
  __commonJS,
  __toESM
} from "./chunk-TCQZMY3T.js";

// ../node_modules/blakejs/util.js
var require_util = __commonJS({
  "../node_modules/blakejs/util.js"(exports, module) {
    var ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
    function normalizeInput(input) {
      let ret;
      if (input instanceof Uint8Array) {
        ret = input;
      } else if (typeof input === "string") {
        const encoder = new TextEncoder();
        ret = encoder.encode(input);
      } else {
        throw new Error(ERROR_MSG_INPUT);
      }
      return ret;
    }
    function toHex(bytes) {
      return Array.prototype.map.call(bytes, function(n) {
        return (n < 16 ? "0" : "") + n.toString(16);
      }).join("");
    }
    function uint32ToHex(val) {
      return (4294967296 + val).toString(16).substring(1);
    }
    function debugPrint(label, arr, size) {
      let msg = "\n" + label + " = ";
      for (let i = 0; i < arr.length; i += 2) {
        if (size === 32) {
          msg += uint32ToHex(arr[i]).toUpperCase();
          msg += " ";
          msg += uint32ToHex(arr[i + 1]).toUpperCase();
        } else if (size === 64) {
          msg += uint32ToHex(arr[i + 1]).toUpperCase();
          msg += uint32ToHex(arr[i]).toUpperCase();
        } else
          throw new Error("Invalid size " + size);
        if (i % 6 === 4) {
          msg += "\n" + new Array(label.length + 4).join(" ");
        } else if (i < arr.length - 2) {
          msg += " ";
        }
      }
      console.log(msg);
    }
    function testSpeed(hashFn, N, M) {
      let startMs = (/* @__PURE__ */ new Date()).getTime();
      const input = new Uint8Array(N);
      for (let i = 0; i < N; i++) {
        input[i] = i % 256;
      }
      const genMs = (/* @__PURE__ */ new Date()).getTime();
      console.log("Generated random input in " + (genMs - startMs) + "ms");
      startMs = genMs;
      for (let i = 0; i < M; i++) {
        const hashHex = hashFn(input);
        const hashMs = (/* @__PURE__ */ new Date()).getTime();
        const ms = hashMs - startMs;
        startMs = hashMs;
        console.log("Hashed in " + ms + "ms: " + hashHex.substring(0, 20) + "...");
        console.log(
          Math.round(N / (1 << 20) / (ms / 1e3) * 100) / 100 + " MB PER SECOND"
        );
      }
    }
    module.exports = {
      normalizeInput,
      toHex,
      debugPrint,
      testSpeed
    };
  }
});

// ../node_modules/blakejs/blake2b.js
var require_blake2b = __commonJS({
  "../node_modules/blakejs/blake2b.js"(exports, module) {
    var util = require_util();
    function ADD64AA(v2, a, b) {
      const o0 = v2[a] + v2[b];
      let o1 = v2[a + 1] + v2[b + 1];
      if (o0 >= 4294967296) {
        o1++;
      }
      v2[a] = o0;
      v2[a + 1] = o1;
    }
    function ADD64AC(v2, a, b0, b1) {
      let o0 = v2[a] + b0;
      if (b0 < 0) {
        o0 += 4294967296;
      }
      let o1 = v2[a + 1] + b1;
      if (o0 >= 4294967296) {
        o1++;
      }
      v2[a] = o0;
      v2[a + 1] = o1;
    }
    function B2B_GET32(arr, i) {
      return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
    }
    function B2B_G(a, b, c, d2, ix, iy) {
      const x0 = m[ix];
      const x1 = m[ix + 1];
      const y0 = m[iy];
      const y1 = m[iy + 1];
      ADD64AA(v, a, b);
      ADD64AC(v, a, x0, x1);
      let xor0 = v[d2] ^ v[a];
      let xor1 = v[d2 + 1] ^ v[a + 1];
      v[d2] = xor1;
      v[d2 + 1] = xor0;
      ADD64AA(v, c, d2);
      xor0 = v[b] ^ v[c];
      xor1 = v[b + 1] ^ v[c + 1];
      v[b] = xor0 >>> 24 ^ xor1 << 8;
      v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
      ADD64AA(v, a, b);
      ADD64AC(v, a, y0, y1);
      xor0 = v[d2] ^ v[a];
      xor1 = v[d2 + 1] ^ v[a + 1];
      v[d2] = xor0 >>> 16 ^ xor1 << 16;
      v[d2 + 1] = xor1 >>> 16 ^ xor0 << 16;
      ADD64AA(v, c, d2);
      xor0 = v[b] ^ v[c];
      xor1 = v[b + 1] ^ v[c + 1];
      v[b] = xor1 >>> 31 ^ xor0 << 1;
      v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
    }
    var BLAKE2B_IV32 = new Uint32Array([
      4089235720,
      1779033703,
      2227873595,
      3144134277,
      4271175723,
      1013904242,
      1595750129,
      2773480762,
      2917565137,
      1359893119,
      725511199,
      2600822924,
      4215389547,
      528734635,
      327033209,
      1541459225
    ]);
    var SIGMA8 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3
    ];
    var SIGMA82 = new Uint8Array(
      SIGMA8.map(function(x) {
        return x * 2;
      })
    );
    var v = new Uint32Array(32);
    var m = new Uint32Array(32);
    function blake2bCompress(ctx, last) {
      let i = 0;
      for (i = 0; i < 16; i++) {
        v[i] = ctx.h[i];
        v[i + 16] = BLAKE2B_IV32[i];
      }
      v[24] = v[24] ^ ctx.t;
      v[25] = v[25] ^ ctx.t / 4294967296;
      if (last) {
        v[28] = ~v[28];
        v[29] = ~v[29];
      }
      for (i = 0; i < 32; i++) {
        m[i] = B2B_GET32(ctx.b, 4 * i);
      }
      for (i = 0; i < 12; i++) {
        B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
      }
      for (i = 0; i < 16; i++) {
        ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
      }
    }
    var parameterBlock = new Uint8Array([
      0,
      0,
      0,
      0,
      //  0: outlen, keylen, fanout, depth
      0,
      0,
      0,
      0,
      //  4: leaf length, sequential mode
      0,
      0,
      0,
      0,
      //  8: node offset
      0,
      0,
      0,
      0,
      // 12: node offset
      0,
      0,
      0,
      0,
      // 16: node depth, inner length, rfu
      0,
      0,
      0,
      0,
      // 20: rfu
      0,
      0,
      0,
      0,
      // 24: rfu
      0,
      0,
      0,
      0,
      // 28: rfu
      0,
      0,
      0,
      0,
      // 32: salt
      0,
      0,
      0,
      0,
      // 36: salt
      0,
      0,
      0,
      0,
      // 40: salt
      0,
      0,
      0,
      0,
      // 44: salt
      0,
      0,
      0,
      0,
      // 48: personal
      0,
      0,
      0,
      0,
      // 52: personal
      0,
      0,
      0,
      0,
      // 56: personal
      0,
      0,
      0,
      0
      // 60: personal
    ]);
    function blake2bInit(outlen, key, salt, personal) {
      if (outlen === 0 || outlen > 64) {
        throw new Error("Illegal output length, expected 0 < length <= 64");
      }
      if (key && key.length > 64) {
        throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
      }
      if (salt && salt.length !== 16) {
        throw new Error("Illegal salt, expected Uint8Array with length is 16");
      }
      if (personal && personal.length !== 16) {
        throw new Error("Illegal personal, expected Uint8Array with length is 16");
      }
      const ctx = {
        b: new Uint8Array(128),
        h: new Uint32Array(16),
        t: 0,
        // input count
        c: 0,
        // pointer within buffer
        outlen
        // output length in bytes
      };
      parameterBlock.fill(0);
      parameterBlock[0] = outlen;
      if (key)
        parameterBlock[1] = key.length;
      parameterBlock[2] = 1;
      parameterBlock[3] = 1;
      if (salt)
        parameterBlock.set(salt, 32);
      if (personal)
        parameterBlock.set(personal, 48);
      for (let i = 0; i < 16; i++) {
        ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4);
      }
      if (key) {
        blake2bUpdate(ctx, key);
        ctx.c = 128;
      }
      return ctx;
    }
    function blake2bUpdate(ctx, input) {
      for (let i = 0; i < input.length; i++) {
        if (ctx.c === 128) {
          ctx.t += ctx.c;
          blake2bCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i];
      }
    }
    function blake2bFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 128) {
        ctx.b[ctx.c++] = 0;
      }
      blake2bCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i = 0; i < ctx.outlen; i++) {
        out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
      }
      return out;
    }
    function blake2b(input, key, outlen, salt, personal) {
      outlen = outlen || 64;
      input = util.normalizeInput(input);
      if (salt) {
        salt = util.normalizeInput(salt);
      }
      if (personal) {
        personal = util.normalizeInput(personal);
      }
      const ctx = blake2bInit(outlen, key, salt, personal);
      blake2bUpdate(ctx, input);
      return blake2bFinal(ctx);
    }
    function blake2bHex(input, key, outlen, salt, personal) {
      const output = blake2b(input, key, outlen, salt, personal);
      return util.toHex(output);
    }
    module.exports = {
      blake2b,
      blake2bHex,
      blake2bInit,
      blake2bUpdate,
      blake2bFinal
    };
  }
});

// ../node_modules/blakejs/blake2s.js
var require_blake2s = __commonJS({
  "../node_modules/blakejs/blake2s.js"(exports, module) {
    var util = require_util();
    function B2S_GET32(v2, i) {
      return v2[i] ^ v2[i + 1] << 8 ^ v2[i + 2] << 16 ^ v2[i + 3] << 24;
    }
    function B2S_G(a, b, c, d2, x, y) {
      v[a] = v[a] + v[b] + x;
      v[d2] = ROTR32(v[d2] ^ v[a], 16);
      v[c] = v[c] + v[d2];
      v[b] = ROTR32(v[b] ^ v[c], 12);
      v[a] = v[a] + v[b] + y;
      v[d2] = ROTR32(v[d2] ^ v[a], 8);
      v[c] = v[c] + v[d2];
      v[b] = ROTR32(v[b] ^ v[c], 7);
    }
    function ROTR32(x, y) {
      return x >>> y ^ x << 32 - y;
    }
    var BLAKE2S_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SIGMA = new Uint8Array([
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0
    ]);
    var v = new Uint32Array(16);
    var m = new Uint32Array(16);
    function blake2sCompress(ctx, last) {
      let i = 0;
      for (i = 0; i < 8; i++) {
        v[i] = ctx.h[i];
        v[i + 8] = BLAKE2S_IV[i];
      }
      v[12] ^= ctx.t;
      v[13] ^= ctx.t / 4294967296;
      if (last) {
        v[14] = ~v[14];
      }
      for (i = 0; i < 16; i++) {
        m[i] = B2S_GET32(ctx.b, 4 * i);
      }
      for (i = 0; i < 10; i++) {
        B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]]);
        B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]]);
        B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]]);
        B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]]);
        B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]]);
        B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]]);
        B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]]);
        B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]]);
      }
      for (i = 0; i < 8; i++) {
        ctx.h[i] ^= v[i] ^ v[i + 8];
      }
    }
    function blake2sInit(outlen, key) {
      if (!(outlen > 0 && outlen <= 32)) {
        throw new Error("Incorrect output length, should be in [1, 32]");
      }
      const keylen = key ? key.length : 0;
      if (key && !(keylen > 0 && keylen <= 32)) {
        throw new Error("Incorrect key length, should be in [1, 32]");
      }
      const ctx = {
        h: new Uint32Array(BLAKE2S_IV),
        // hash state
        b: new Uint8Array(64),
        // input block
        c: 0,
        // pointer within block
        t: 0,
        // input count
        outlen
        // output length in bytes
      };
      ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
      if (keylen > 0) {
        blake2sUpdate(ctx, key);
        ctx.c = 64;
      }
      return ctx;
    }
    function blake2sUpdate(ctx, input) {
      for (let i = 0; i < input.length; i++) {
        if (ctx.c === 64) {
          ctx.t += ctx.c;
          blake2sCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i];
      }
    }
    function blake2sFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 64) {
        ctx.b[ctx.c++] = 0;
      }
      blake2sCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i = 0; i < ctx.outlen; i++) {
        out[i] = ctx.h[i >> 2] >> 8 * (i & 3) & 255;
      }
      return out;
    }
    function blake2s(input, key, outlen) {
      outlen = outlen || 32;
      input = util.normalizeInput(input);
      const ctx = blake2sInit(outlen, key);
      blake2sUpdate(ctx, input);
      return blake2sFinal(ctx);
    }
    function blake2sHex(input, key, outlen) {
      const output = blake2s(input, key, outlen);
      return util.toHex(output);
    }
    module.exports = {
      blake2s,
      blake2sHex,
      blake2sInit,
      blake2sUpdate,
      blake2sFinal
    };
  }
});

// ../node_modules/blakejs/index.js
var require_blakejs = __commonJS({
  "../node_modules/blakejs/index.js"(exports, module) {
    var b2b = require_blake2b();
    var b2s = require_blake2s();
    module.exports = {
      blake2b: b2b.blake2b,
      blake2bHex: b2b.blake2bHex,
      blake2bInit: b2b.blake2bInit,
      blake2bUpdate: b2b.blake2bUpdate,
      blake2bFinal: b2b.blake2bFinal,
      blake2s: b2s.blake2s,
      blake2sHex: b2s.blake2sHex,
      blake2sInit: b2s.blake2sInit,
      blake2sUpdate: b2s.blake2sUpdate,
      blake2sFinal: b2s.blake2sFinal
    };
  }
});

// ../node_modules/lit-svelte-stores/dist/store-subscriber.js
var StoreSubscriber = class {
  constructor(host, getStore, resubscribeIfChanged) {
    this.host = host;
    this.getStore = getStore;
    this.resubscribeIfChanged = resubscribeIfChanged;
    host.addController(this);
  }
  hostUpdate() {
    const store = this.store();
    if (this.shouldResubscribe(store)) {
      this.unsubscribe();
      if (store) {
        this._unsubscribe = store.subscribe((value) => {
          this.value = value;
          this.host.requestUpdate();
        });
      }
      this._previousStore = store;
    }
  }
  hostDisconnected() {
    this.unsubscribe();
  }
  unsubscribe() {
    if (this._unsubscribe) {
      this._unsubscribe();
      this._unsubscribe = void 0;
    }
  }
  shouldResubscribe(store) {
    if (this.resubscribeIfChanged) {
      const args = this.resubscribeIfChanged();
      const prev = this._previousArgs;
      this._previousArgs = args;
      return !isEqual_default(args, prev);
    } else {
      if (store === this._previousStore)
        return false;
      if (store && this._previousStore && get_store_value(store) === this.value)
        return false;
      return true;
    }
  }
  store() {
    return this.getStore();
  }
};

// ../node_modules/@lit-labs/task/development/task.js
var initialState = Symbol();

// node_modules/@holochain-open-dev/stores/dist/async-derived.js
var isPromise = (v) => typeof v === "object" && typeof v.then === "function";
function asyncDerived(store, derive) {
  return derived(store, (value, set) => {
    if (value.status === "error")
      set(value);
    else if (value.status === "pending")
      set(value);
    else {
      const v = derive(value.value);
      if (isPromise(v)) {
        set({ status: "pending" });
        Promise.resolve(v).then((v2) => {
          set({
            status: "complete",
            value: v2
          });
        }).catch((error) => {
          set({
            status: "error",
            error
          });
        });
      } else {
        set({
          status: "complete",
          value: v
        });
      }
    }
  });
}
function join(stores) {
  return derived(stores, (values) => {
    const firstError = values.find((v2) => v2 && v2.status === "error");
    if (firstError) {
      return firstError;
    }
    const firstLoading = values.find((v2) => v2 && v2.status === "pending");
    if (firstLoading) {
      return firstLoading;
    }
    const v = values.map((v2) => {
      if (v2 && v2.status === "complete")
        return v2.value;
      return v2;
    });
    return {
      status: "complete",
      value: v
    };
  });
}
function asyncDeriveStore(store, deriveStoreFn) {
  return derived(store, (value, set) => {
    if (value.status === "error")
      set(value);
    else if (value.status === "pending")
      set(value);
    else {
      const v = deriveStoreFn(value.value);
      if (isPromise(v)) {
        let unsubscribe;
        set({ status: "pending" });
        Promise.resolve(v).then((v2) => {
          unsubscribe = v2.subscribe(set);
        }).catch((error) => {
          set({
            status: "error",
            error
          });
        });
        return () => {
          if (unsubscribe)
            unsubscribe();
        };
      } else {
        return v.subscribe((v2) => {
          set(v2);
        });
      }
    }
    return void 0;
  });
}

// node_modules/@holochain-open-dev/stores/dist/async-readable.js
function asyncReadable(load) {
  return readable({ status: "pending" }, (set) => {
    const asyncSet = (v) => set({ status: "complete", value: v });
    let unsubscribe;
    load(asyncSet).then((u) => {
      unsubscribe = u;
    }).catch((e) => set({ status: "error", error: e }));
    return () => unsubscribe && unsubscribe();
  });
}
function lazyLoad(load) {
  return readable({ status: "pending" }, (set) => {
    load().then((v) => {
      set({ status: "complete", value: v });
    }).catch((e) => set({ status: "error", error: e }));
    return () => {
    };
  });
}
function lazyLoadAndPoll(load, pollIntervalMs) {
  return readable({ status: "pending" }, (set) => {
    let interval;
    let currentValue;
    let firstLoad = true;
    async function l() {
      const v = await load();
      if (firstLoad || !isEqual_default(v, currentValue)) {
        currentValue = v;
        firstLoad = false;
        set({ status: "complete", value: v });
      }
    }
    l().then(() => {
      interval = setInterval(() => l().catch(() => {
      }), pollIntervalMs);
    }).catch((e) => {
      set({ status: "error", error: e });
    });
    return () => {
      if (interval)
        clearInterval(interval);
    };
  });
}

// node_modules/@holochain-open-dev/utils/node_modules/@holochain/client/lib/api/admin/types.js
var CellType;
(function(CellType2) {
  CellType2["Provisioned"] = "provisioned";
  CellType2["Cloned"] = "cloned";
  CellType2["Stem"] = "stem";
})(CellType || (CellType = {}));
var CellProvisioningStrategy;
(function(CellProvisioningStrategy2) {
  CellProvisioningStrategy2["Create"] = "create";
  CellProvisioningStrategy2["UseExisting"] = "use_existing";
  CellProvisioningStrategy2["CreateIfNoExists"] = "create_if_no_exists";
})(CellProvisioningStrategy || (CellProvisioningStrategy = {}));
var AppStatusFilter;
(function(AppStatusFilter2) {
  AppStatusFilter2["Enabled"] = "enabled";
  AppStatusFilter2["Disabled"] = "disabled";
  AppStatusFilter2["Running"] = "running";
  AppStatusFilter2["Stopped"] = "stopped";
  AppStatusFilter2["Paused"] = "paused";
})(AppStatusFilter || (AppStatusFilter = {}));

// node_modules/@holochain-open-dev/utils/node_modules/@holochain/client/lib/utils/base64.js
function decodeHashFromBase64(hash2) {
  return gBase64.toUint8Array(hash2.slice(1));
}
function encodeHashToBase64(hash2) {
  return `u${gBase64.fromUint8Array(hash2, true)}`;
}

// node_modules/@holochain-open-dev/utils/node_modules/@holochain/client/lib/api/zome-call-signing.js
if (!globalThis.crypto) {
  import("./node_crypto-ZKBL4SRI.js").then((webcrypto) => globalThis.crypto = webcrypto);
}

// node_modules/@holochain-open-dev/utils/node_modules/@holochain/client/lib/environments/launcher.js
var __HC_LAUNCHER_ENV__ = "__HC_LAUNCHER_ENV__";
var isLauncher = globalThis.window && __HC_LAUNCHER_ENV__ in globalThis.window;

// node_modules/@holochain-open-dev/utils/node_modules/@holochain/client/lib/hdk/capabilities.js
var GrantedFunctionsType;
(function(GrantedFunctionsType2) {
  GrantedFunctionsType2["All"] = "All";
  GrantedFunctionsType2["Listed"] = "Listed";
})(GrantedFunctionsType || (GrantedFunctionsType = {}));

// node_modules/@holochain-open-dev/utils/node_modules/@holochain/client/lib/hdk/action.js
var ActionType;
(function(ActionType2) {
  ActionType2["Dna"] = "Dna";
  ActionType2["AgentValidationPkg"] = "AgentValidationPkg";
  ActionType2["InitZomesComplete"] = "InitZomesComplete";
  ActionType2["CreateLink"] = "CreateLink";
  ActionType2["DeleteLink"] = "DeleteLink";
  ActionType2["OpenChain"] = "OpenChain";
  ActionType2["CloseChain"] = "CloseChain";
  ActionType2["Create"] = "Create";
  ActionType2["Update"] = "Update";
  ActionType2["Delete"] = "Delete";
})(ActionType || (ActionType = {}));

// node_modules/@holochain-open-dev/utils/node_modules/@holochain/client/lib/hdk/dht-ops.js
var DhtOpType;
(function(DhtOpType2) {
  DhtOpType2["StoreRecord"] = "StoreRecord";
  DhtOpType2["StoreEntry"] = "StoreEntry";
  DhtOpType2["RegisterAgentActivity"] = "RegisterAgentActivity";
  DhtOpType2["RegisterUpdatedContent"] = "RegisterUpdatedContent";
  DhtOpType2["RegisterUpdatedRecord"] = "RegisterUpdatedRecord";
  DhtOpType2["RegisterDeletedBy"] = "RegisterDeletedBy";
  DhtOpType2["RegisterDeletedEntryAction"] = "RegisterDeletedEntryAction";
  DhtOpType2["RegisterAddLink"] = "RegisterAddLink";
  DhtOpType2["RegisterRemoveLink"] = "RegisterRemoveLink";
})(DhtOpType || (DhtOpType = {}));

// node_modules/@holochain-open-dev/utils/dist/hash.js
var import_blakejs = __toESM(require_blakejs(), 1);
var HashType;
(function(HashType2) {
  HashType2[HashType2["AGENT"] = 0] = "AGENT";
  HashType2[HashType2["ENTRY"] = 1] = "ENTRY";
  HashType2[HashType2["DHTOP"] = 2] = "DHTOP";
  HashType2[HashType2["ACTION"] = 3] = "ACTION";
  HashType2[HashType2["DNA"] = 4] = "DNA";
})(HashType || (HashType = {}));

// node_modules/@holochain-open-dev/utils/dist/cell.js
function roleNameForCellId(appInfo, cellId) {
  for (const [role, cells] of Object.entries(appInfo.cell_info)) {
    for (const c of cells) {
      if (CellType.Provisioned in c) {
        if (c[CellType.Provisioned].cell_id.toString() === cellId.toString()) {
          return role;
        }
      } else if (CellType.Cloned in c) {
        return c[CellType.Cloned].clone_id ? c[CellType.Cloned].clone_id : role;
      }
    }
  }
  return void 0;
}
async function isSignalFromCellWithRole(client, roleName, signal) {
  const appInfo = await client.appInfo();
  const role = roleNameForCellId(appInfo, signal.cell_id);
  return roleName === role;
}

// node_modules/@holochain-open-dev/utils/dist/zome-client.js
var ZomeClient = class {
  constructor(client, roleName, zomeName) {
    this.client = client;
    this.roleName = roleName;
    this.zomeName = zomeName;
  }
  onSignal(listener) {
    return this.client.on("signal", async (signal) => {
      if (await isSignalFromCellWithRole(this.client, this.roleName, signal) && this.zomeName === signal.zome_name) {
        listener(signal.payload);
      }
    });
  }
  callZome(fn_name, payload) {
    const req = {
      role_name: this.roleName,
      zome_name: this.zomeName,
      fn_name,
      payload
    };
    return this.client.callZome(req);
  }
};

// node_modules/@holochain-open-dev/utils/dist/holo-hash-map.js
var _CellMap_cellMap;
var HoloHashMap = class {
  constructor(initialEntries) {
    this._map = /* @__PURE__ */ new Map();
    if (initialEntries) {
      for (const [key, value] of initialEntries) {
        this.set(key, value);
      }
    }
  }
  has(key) {
    return this._map.has(encodeHashToBase64(key));
  }
  get(key) {
    return this._map.get(encodeHashToBase64(key));
  }
  set(key, value) {
    this._map.set(encodeHashToBase64(key), value);
    return this;
  }
  delete(key) {
    return this._map.delete(encodeHashToBase64(key));
  }
  keys() {
    return Array.from(this._map.keys()).map((h) => decodeHashFromBase64(h))[Symbol.iterator]();
  }
  values() {
    return this._map.values();
  }
  entries() {
    return Array.from(this._map.entries()).map(([h, v]) => [decodeHashFromBase64(h), v])[Symbol.iterator]();
  }
  clear() {
    return this._map.clear();
  }
  forEach(callbackfn, thisArg) {
    return this._map.forEach((value, key) => {
      callbackfn(value, decodeHashFromBase64(key), this);
    }, thisArg);
  }
  get size() {
    return this._map.size;
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get [Symbol.toStringTag]() {
    return this._map[Symbol.toStringTag];
  }
};
_CellMap_cellMap = /* @__PURE__ */ new WeakMap();
var LazyHoloHashMap = class {
  constructor(newValue) {
    this.newValue = newValue;
    this.map = new HoloHashMap();
  }
  get(hash2) {
    if (!this.map.has(hash2)) {
      this.map.set(hash2, this.newValue(hash2));
    }
    return this.map.get(hash2);
  }
};

// node_modules/@holochain-open-dev/utils/dist/map-utils.js
function slice(map, keys) {
  const newMap = new HoloHashMap();
  for (const key of keys) {
    newMap.set(key, map.get(key));
  }
  return newMap;
}

// node_modules/@holochain-open-dev/utils/dist/entry-record.js
function decodeEntry(record) {
  var _a, _b;
  const entry = (_b = (_a = record.entry) == null ? void 0 : _a.Present) == null ? void 0 : _b.entry;
  return decode(entry);
}

// node_modules/@holochain-open-dev/stores/dist/join-map.js
function joinAsyncMap(holoHashMap) {
  const storeArray = Array.from(holoHashMap.entries()).map(([key, store]) => asyncDerived(store, (v) => [key, v]));
  const arrayStore = join(storeArray);
  return asyncDerived(arrayStore, (entries) => new HoloHashMap(entries));
}

// node_modules/@holochain-open-dev/stores/dist/manual.js
function manualReloadStore(fn) {
  const store = writable({ status: "pending" });
  const reload = async () => {
    try {
      const value = await fn();
      store.set({
        status: "complete",
        value
      });
    } catch (error) {
      store.set({ status: "error", error });
    }
  };
  reload();
  return {
    subscribe: store.subscribe,
    reload
  };
}

export {
  ZomeClient,
  LazyHoloHashMap,
  slice,
  decodeEntry,
  StoreSubscriber,
  asyncDeriveStore,
  asyncReadable,
  lazyLoad,
  lazyLoadAndPoll,
  joinAsyncMap,
  manualReloadStore
};
/*! Bundled license information:

@lit-labs/task/development/task.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit-labs/task/development/index.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=chunk-4Z3R6YLO.js.map
