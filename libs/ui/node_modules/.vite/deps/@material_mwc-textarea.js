import {
  TextFieldBase,
  styles
} from "./chunk-JCYBEGBL.js";
import {
  live
} from "./chunk-DURKRWBH.js";
import "./chunk-IFZRPEIZ.js";
import "./chunk-CCLU3OJM.js";
import "./chunk-3RT6BUHN.js";
import "./chunk-BJ2UCMSJ.js";
import {
  ifDefined
} from "./chunk-3UHMJHWB.js";
import "./chunk-K2GWU6W5.js";
import {
  classMap
} from "./chunk-XHTW3CQQ.js";
import {
  customElement,
  property,
  query
} from "./chunk-LLKFEKJC.js";
import {
  html
} from "./chunk-KJJ2SZCS.js";
import "./chunk-HKTNVJXR.js";
import {
  css
} from "./chunk-QK5UQRR6.js";
import "./chunk-TCQZMY3T.js";

// ../node_modules/@material/mwc-textarea/node_modules/tslib/tslib.es6.js
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// ../node_modules/@material/mwc-textarea/mwc-textarea-base.js
var booleanOrStringConverter = {
  fromAttribute(value) {
    if (value === null) {
      return false;
    } else if (value === "") {
      return true;
    }
    return value;
  },
  toAttribute(value) {
    if (typeof value === "boolean") {
      return value ? "" : null;
    }
    return value;
  }
};
var TextAreaBase = class extends TextFieldBase {
  constructor() {
    super(...arguments);
    this.rows = 2;
    this.cols = 20;
    this.charCounter = false;
  }
  /** @soyTemplate */
  render() {
    const shouldRenderCharCounter = this.charCounter && this.maxLength !== -1;
    const shouldRenderInternalCharCounter = shouldRenderCharCounter && this.charCounter === "internal";
    const shouldRenderExternalCharCounter = shouldRenderCharCounter && !shouldRenderInternalCharCounter;
    const shouldRenderHelperText = !!this.helper || !!this.validationMessage || shouldRenderExternalCharCounter;
    const classes = {
      "mdc-text-field--disabled": this.disabled,
      "mdc-text-field--no-label": !this.label,
      "mdc-text-field--filled": !this.outlined,
      "mdc-text-field--outlined": this.outlined,
      "mdc-text-field--end-aligned": this.endAligned,
      "mdc-text-field--with-internal-counter": shouldRenderInternalCharCounter
    };
    return html`
      <label class="mdc-text-field mdc-text-field--textarea ${classMap(classes)}">
        ${this.renderRipple()}
        ${this.outlined ? this.renderOutline() : this.renderLabel()}
        ${this.renderInput()}
        ${this.renderCharCounter(shouldRenderInternalCharCounter)}
        ${this.renderLineRipple()}
      </label>
      ${this.renderHelperText(shouldRenderHelperText, shouldRenderExternalCharCounter)}
    `;
  }
  /** @soyTemplate */
  renderInput() {
    const ariaLabelledbyOrUndef = !!this.label ? "label" : void 0;
    const minOrUndef = this.minLength === -1 ? void 0 : this.minLength;
    const maxOrUndef = this.maxLength === -1 ? void 0 : this.maxLength;
    const autocapitalizeOrUndef = this.autocapitalize ? this.autocapitalize : void 0;
    return html`
      <textarea
          aria-labelledby=${ifDefined(ariaLabelledbyOrUndef)}
          class="mdc-text-field__input"
          .value="${live(this.value)}"
          rows="${this.rows}"
          cols="${this.cols}"
          ?disabled="${this.disabled}"
          placeholder="${this.placeholder}"
          ?required="${this.required}"
          ?readonly="${this.readOnly}"
          minlength="${ifDefined(minOrUndef)}"
          maxlength="${ifDefined(maxOrUndef)}"
          name="${ifDefined(this.name === "" ? void 0 : this.name)}"
          inputmode="${ifDefined(this.inputMode)}"
          autocapitalize="${ifDefined(autocapitalizeOrUndef)}"
          @input="${this.handleInputChange}"
          @blur="${this.onInputBlur}">
      </textarea>`;
  }
};
__decorate([
  query("textarea")
], TextAreaBase.prototype, "formElement", void 0);
__decorate([
  property({ type: Number })
], TextAreaBase.prototype, "rows", void 0);
__decorate([
  property({ type: Number })
], TextAreaBase.prototype, "cols", void 0);
__decorate([
  property({ converter: booleanOrStringConverter })
], TextAreaBase.prototype, "charCounter", void 0);

// ../node_modules/@material/mwc-textarea/mwc-textarea.css.js
var styles2 = css`.mdc-text-field{height:100%}.mdc-text-field__input{resize:none}`;

// ../node_modules/@material/mwc-textarea/mwc-textarea.js
var TextArea = class TextArea2 extends TextAreaBase {
};
TextArea.styles = [styles, styles2];
TextArea = __decorate([
  customElement("mwc-textarea")
], TextArea);
export {
  TextArea
};
/*! Bundled license information:

@material/mwc-textarea/mwc-textarea-base.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

@material/mwc-textarea/mwc-textarea.css.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-LIcense-Identifier: Apache-2.0
   *)

@material/mwc-textarea/mwc-textarea.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=@material_mwc-textarea.js.map
