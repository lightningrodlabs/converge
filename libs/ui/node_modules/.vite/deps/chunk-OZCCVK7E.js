import {
  localized,
  msg
} from "./chunk-VJMV55IO.js";
import {
  encodeHashToBase64,
  hashProperty
} from "./chunk-WEAYHYO7.js";
import {
  classMap
} from "./chunk-XHTW3CQQ.js";
import {
  customElement,
  property,
  query,
  state
} from "./chunk-LLKFEKJC.js";
import {
  LitElement,
  html
} from "./chunk-KJJ2SZCS.js";
import {
  css
} from "./chunk-QK5UQRR6.js";

// ../node_modules/@holo-host/identicon/index.js
var bytes = [0];
var byteIndex = 0;
function setBytes(hash) {
  if (hash[0] === 132 && hash[1] === 32 && hash[2] === 36) {
    bytes = hash.slice(3);
  } else {
    bytes = hash || [];
  }
  byteIndex = 0;
}
function value() {
  const getByte = () => {
    const result = bytes[byteIndex];
    byteIndex = (byteIndex + 1) % bytes.length;
    return result;
  };
  return getByte() / 256;
}
function createColor(lightness) {
  const h = Math.floor(value() * 360);
  const s = value() * 60 + 40;
  const l = lightness || (value() * 100 + (value() + value() + value() + value()) * 25) / 2;
  return { h, s, l };
}
function encodeColor({ h, s, l }) {
  return `hsl(${h}, ${s}%, ${l}%)`;
}
function drawTriangle(cc, radius, center) {
  const a1 = value() * 2 * Math.PI;
  const dx1 = radius * Math.cos(a1);
  const dy1 = radius * Math.sin(a1);
  const x1 = center.x + dx1;
  const y1 = center.x + dy1;
  const a2 = a1 + 2 * Math.PI * 0.3;
  const dx2 = radius * Math.cos(a2);
  const dy2 = radius * Math.sin(a2);
  const x2 = center.x + dx2;
  const y2 = center.x + dy2;
  const a3 = a2 + 2 * Math.PI * 0.3;
  const dx3 = radius * Math.cos(a3);
  const dy3 = radius * Math.sin(a3);
  const x3 = center.x + dx3;
  const y3 = center.x + dy3;
  cc.beginPath();
  cc.moveTo(x1, y1);
  cc.lineTo(x2, y2);
  cc.lineTo(x3, y3);
  cc.fill();
}
function buildOpts(opts) {
  const hash = opts.hash || [0];
  setBytes(hash);
  return {
    backgroundColor: opts.backgroundColor || encodeColor(createColor()),
    hash,
    size: opts.size || 32
  };
}
function renderIdenticon(opts, canvas) {
  if (opts.hash && !(opts.hash instanceof Uint8Array)) {
    throw new Error("invalid type for opts.hash, expecting Uint8Array or null");
  }
  opts = buildOpts(opts || {});
  const { size, backgroundColor } = opts;
  canvas.width = canvas.height = size;
  const cc = canvas.getContext("2d");
  if (!cc)
    return;
  cc.fillStyle = backgroundColor;
  cc.fillRect(0, 0, canvas.width, canvas.height);
  const numShapes = value() < 0.5 ? 3 : 4;
  const shapes = Array.apply(null, Array(numShapes)).map((_, i) => {
    const lightness = i === 0 ? 5 + value() * 25 : i === 1 ? 70 + value() * 25 : null;
    return {
      x: value() * size,
      y: value() * size,
      radius: 5 + value() * size * 0.25,
      type: Math.floor(value() * 3),
      color: encodeColor(createColor(lightness))
    };
  }).sort((a, b) => a.radius > b.radius ? -1 : 1);
  for (let i = 0; i < numShapes; i++) {
    const shape = shapes[i];
    const { x, y, radius, type, color } = shape;
    cc.fillStyle = color;
    switch (type) {
      case 0:
        cc.beginPath();
        cc.arc(x, y, radius, 0, 2 * Math.PI);
        cc.fill();
        break;
      case 1:
        cc.fillRect(x, y, radius * 2, radius * 2);
        break;
      case 2:
        drawTriangle(cc, radius * 2, { x, y });
        break;
      default:
        throw new Error("shape is greater than 2, this should never happen");
    }
  }
  return canvas;
}

// node_modules/@holochain-open-dev/elements/dist/elements/holo-identicon.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var HoloIdenticon = class HoloIdenticon2 extends LitElement {
  constructor() {
    super(...arguments);
    this.size = 32;
    this.shape = "circle";
    this.disableTooltip = false;
    this.disableCopy = false;
    this.justCopiedHash = false;
  }
  async copyHash() {
    if (this.disableCopy)
      return;
    await navigator.clipboard.writeText(this.strHash);
    if (this.timeout)
      clearTimeout(this.timeout);
    this.justCopiedHash = true;
    this._tooltip.show();
    this.timeout = setTimeout(() => {
      this._tooltip.hide();
      setTimeout(() => {
        this.justCopiedHash = false;
      }, 100);
    }, 2e3);
  }
  get strHash() {
    return encodeHashToBase64(this.hash);
  }
  updated(changedValues) {
    var _a, _b;
    super.updated(changedValues);
    if (changedValues.has("hash") && ((_a = changedValues.get("hash")) == null ? void 0 : _a.toString()) !== ((_b = this.hash) == null ? void 0 : _b.toString()) || changedValues.has("size") || changedValues.has("value")) {
      renderIdenticon({
        hash: this.hash,
        size: this.size
      }, this._canvas);
    }
  }
  renderCanvas() {
    return html` <canvas
      id="canvas"
      width="1"
      height="1"
      class=${classMap({
      square: this.shape === "square",
      circle: this.shape === "circle"
    })}
    ></canvas>`;
  }
  render() {
    return html`<div
      @click=${() => this.copyHash()}
      style="${this.disableCopy ? "" : "cursor: pointer;"} flex-grow: 0"
    >
      <sl-tooltip
        id="tooltip"
        placement="top"
        .content=${this.justCopiedHash ? msg("Copied!") : `${this.strHash.substring(0, 6)}...`}
        .trigger=${this.disableTooltip || this.justCopiedHash ? "manual" : "hover focus"}
        hoist
      >
        ${this.renderCanvas()}
      </sl-tooltip>
    </div>`;
  }
  static get styles() {
    return css`
      :host {
        display: flex;
      }

      .square {
        border-radius: 0%;
      }
      .circle {
        border-radius: 50%;
      }
    `;
  }
};
__decorate([
  property(hashProperty("hash"))
], HoloIdenticon.prototype, "hash", void 0);
__decorate([
  property({ type: Number })
], HoloIdenticon.prototype, "size", void 0);
__decorate([
  property({ type: String })
], HoloIdenticon.prototype, "shape", void 0);
__decorate([
  property({ type: Boolean, attribute: "disable-tooltip" })
], HoloIdenticon.prototype, "disableTooltip", void 0);
__decorate([
  property({ type: Boolean, attribute: "disable-copy" })
], HoloIdenticon.prototype, "disableCopy", void 0);
__decorate([
  query("#canvas")
], HoloIdenticon.prototype, "_canvas", void 0);
__decorate([
  query("#tooltip")
], HoloIdenticon.prototype, "_tooltip", void 0);
__decorate([
  state()
], HoloIdenticon.prototype, "justCopiedHash", void 0);
HoloIdenticon = __decorate([
  localized(),
  customElement("holo-identicon")
], HoloIdenticon);
//# sourceMappingURL=chunk-OZCCVK7E.js.map
