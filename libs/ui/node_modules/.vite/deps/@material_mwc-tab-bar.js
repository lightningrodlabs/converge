import {
  TabBase
} from "./chunk-QB3VFIWW.js";
import {
  observer
} from "./chunk-3RT6BUHN.js";
import {
  matches
} from "./chunk-MZAI3YEV.js";
import "./chunk-QBLXO4ZU.js";
import "./chunk-WQJA2ZTO.js";
import {
  BaseElement,
  MDCFoundation,
  addHasRemoveClass
} from "./chunk-K2GWU6W5.js";
import "./chunk-XHTW3CQQ.js";
import {
  customElement,
  eventOptions,
  property,
  query
} from "./chunk-LLKFEKJC.js";
import {
  html
} from "./chunk-KJJ2SZCS.js";
import "./chunk-HKTNVJXR.js";
import {
  css
} from "./chunk-QK5UQRR6.js";
import "./chunk-TCQZMY3T.js";

// ../node_modules/@material/mwc-tab-bar/node_modules/tslib/tslib.es6.mjs
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// ../node_modules/@material/mwc-tab-scroller/node_modules/tslib/tslib.es6.mjs
function __decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// ../node_modules/@material/tab-scroller/node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}

// ../node_modules/@material/tab-scroller/constants.js
var cssClasses = {
  ANIMATING: "mdc-tab-scroller--animating",
  SCROLL_AREA_SCROLL: "mdc-tab-scroller__scroll-area--scroll",
  SCROLL_TEST: "mdc-tab-scroller__test"
};
var strings = {
  AREA_SELECTOR: ".mdc-tab-scroller__scroll-area",
  CONTENT_SELECTOR: ".mdc-tab-scroller__scroll-content"
};

// ../node_modules/@material/tab-scroller/rtl-scroller.js
var MDCTabScrollerRTL = (
  /** @class */
  function() {
    function MDCTabScrollerRTL2(adapter) {
      this.adapter = adapter;
    }
    return MDCTabScrollerRTL2;
  }()
);

// ../node_modules/@material/tab-scroller/rtl-default-scroller.js
var MDCTabScrollerRTLDefault = (
  /** @class */
  function(_super) {
    __extends(MDCTabScrollerRTLDefault2, _super);
    function MDCTabScrollerRTLDefault2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTabScrollerRTLDefault2.prototype.getScrollPositionRTL = function() {
      var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
      var right = this.calculateScrollEdges().right;
      return Math.round(right - currentScrollLeft);
    };
    MDCTabScrollerRTLDefault2.prototype.scrollToRTL = function(scrollX) {
      var edges = this.calculateScrollEdges();
      var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
      var clampedScrollLeft = this.clampScrollValue(edges.right - scrollX);
      return {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: clampedScrollLeft - currentScrollLeft
      };
    };
    MDCTabScrollerRTLDefault2.prototype.incrementScrollRTL = function(scrollX) {
      var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
      var clampedScrollLeft = this.clampScrollValue(currentScrollLeft - scrollX);
      return {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: clampedScrollLeft - currentScrollLeft
      };
    };
    MDCTabScrollerRTLDefault2.prototype.getAnimatingScrollPosition = function(scrollX) {
      return scrollX;
    };
    MDCTabScrollerRTLDefault2.prototype.calculateScrollEdges = function() {
      var contentWidth = this.adapter.getScrollContentOffsetWidth();
      var rootWidth = this.adapter.getScrollAreaOffsetWidth();
      return {
        left: 0,
        right: contentWidth - rootWidth
      };
    };
    MDCTabScrollerRTLDefault2.prototype.clampScrollValue = function(scrollX) {
      var edges = this.calculateScrollEdges();
      return Math.min(Math.max(edges.left, scrollX), edges.right);
    };
    return MDCTabScrollerRTLDefault2;
  }(MDCTabScrollerRTL)
);

// ../node_modules/@material/tab-scroller/rtl-negative-scroller.js
var MDCTabScrollerRTLNegative = (
  /** @class */
  function(_super) {
    __extends(MDCTabScrollerRTLNegative2, _super);
    function MDCTabScrollerRTLNegative2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTabScrollerRTLNegative2.prototype.getScrollPositionRTL = function(translateX) {
      var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
      return Math.round(translateX - currentScrollLeft);
    };
    MDCTabScrollerRTLNegative2.prototype.scrollToRTL = function(scrollX) {
      var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
      var clampedScrollLeft = this.clampScrollValue(-scrollX);
      return {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: clampedScrollLeft - currentScrollLeft
      };
    };
    MDCTabScrollerRTLNegative2.prototype.incrementScrollRTL = function(scrollX) {
      var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
      var clampedScrollLeft = this.clampScrollValue(currentScrollLeft - scrollX);
      return {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: clampedScrollLeft - currentScrollLeft
      };
    };
    MDCTabScrollerRTLNegative2.prototype.getAnimatingScrollPosition = function(scrollX, translateX) {
      return scrollX - translateX;
    };
    MDCTabScrollerRTLNegative2.prototype.calculateScrollEdges = function() {
      var contentWidth = this.adapter.getScrollContentOffsetWidth();
      var rootWidth = this.adapter.getScrollAreaOffsetWidth();
      return {
        left: rootWidth - contentWidth,
        right: 0
      };
    };
    MDCTabScrollerRTLNegative2.prototype.clampScrollValue = function(scrollX) {
      var edges = this.calculateScrollEdges();
      return Math.max(Math.min(edges.right, scrollX), edges.left);
    };
    return MDCTabScrollerRTLNegative2;
  }(MDCTabScrollerRTL)
);

// ../node_modules/@material/tab-scroller/rtl-reverse-scroller.js
var MDCTabScrollerRTLReverse = (
  /** @class */
  function(_super) {
    __extends(MDCTabScrollerRTLReverse2, _super);
    function MDCTabScrollerRTLReverse2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTabScrollerRTLReverse2.prototype.getScrollPositionRTL = function(translateX) {
      var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
      return Math.round(currentScrollLeft - translateX);
    };
    MDCTabScrollerRTLReverse2.prototype.scrollToRTL = function(scrollX) {
      var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
      var clampedScrollLeft = this.clampScrollValue(scrollX);
      return {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: currentScrollLeft - clampedScrollLeft
      };
    };
    MDCTabScrollerRTLReverse2.prototype.incrementScrollRTL = function(scrollX) {
      var currentScrollLeft = this.adapter.getScrollAreaScrollLeft();
      var clampedScrollLeft = this.clampScrollValue(currentScrollLeft + scrollX);
      return {
        finalScrollPosition: clampedScrollLeft,
        scrollDelta: currentScrollLeft - clampedScrollLeft
      };
    };
    MDCTabScrollerRTLReverse2.prototype.getAnimatingScrollPosition = function(scrollX, translateX) {
      return scrollX + translateX;
    };
    MDCTabScrollerRTLReverse2.prototype.calculateScrollEdges = function() {
      var contentWidth = this.adapter.getScrollContentOffsetWidth();
      var rootWidth = this.adapter.getScrollAreaOffsetWidth();
      return {
        left: contentWidth - rootWidth,
        right: 0
      };
    };
    MDCTabScrollerRTLReverse2.prototype.clampScrollValue = function(scrollX) {
      var edges = this.calculateScrollEdges();
      return Math.min(Math.max(edges.right, scrollX), edges.left);
    };
    return MDCTabScrollerRTLReverse2;
  }(MDCTabScrollerRTL)
);

// ../node_modules/@material/tab-scroller/foundation.js
var MDCTabScrollerFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCTabScrollerFoundation2, _super);
    function MDCTabScrollerFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCTabScrollerFoundation2.defaultAdapter), adapter)) || this;
      _this.isAnimating = false;
      return _this;
    }
    Object.defineProperty(MDCTabScrollerFoundation2, "cssClasses", {
      get: function() {
        return cssClasses;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTabScrollerFoundation2, "strings", {
      get: function() {
        return strings;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTabScrollerFoundation2, "defaultAdapter", {
      get: function() {
        return {
          eventTargetMatchesSelector: function() {
            return false;
          },
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          addScrollAreaClass: function() {
            return void 0;
          },
          setScrollAreaStyleProperty: function() {
            return void 0;
          },
          setScrollContentStyleProperty: function() {
            return void 0;
          },
          getScrollContentStyleValue: function() {
            return "";
          },
          setScrollAreaScrollLeft: function() {
            return void 0;
          },
          getScrollAreaScrollLeft: function() {
            return 0;
          },
          getScrollContentOffsetWidth: function() {
            return 0;
          },
          getScrollAreaOffsetWidth: function() {
            return 0;
          },
          computeScrollAreaClientRect: function() {
            return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
          },
          computeScrollContentClientRect: function() {
            return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
          },
          computeHorizontalScrollbarHeight: function() {
            return 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCTabScrollerFoundation2.prototype.init = function() {
      var horizontalScrollbarHeight = this.adapter.computeHorizontalScrollbarHeight();
      this.adapter.setScrollAreaStyleProperty("margin-bottom", -horizontalScrollbarHeight + "px");
      this.adapter.addScrollAreaClass(MDCTabScrollerFoundation2.cssClasses.SCROLL_AREA_SCROLL);
    };
    MDCTabScrollerFoundation2.prototype.getScrollPosition = function() {
      if (this.isRTL()) {
        return this.computeCurrentScrollPositionRTL();
      }
      var currentTranslateX = this.calculateCurrentTranslateX();
      var scrollLeft = this.adapter.getScrollAreaScrollLeft();
      return scrollLeft - currentTranslateX;
    };
    MDCTabScrollerFoundation2.prototype.handleInteraction = function() {
      if (!this.isAnimating) {
        return;
      }
      this.stopScrollAnimation();
    };
    MDCTabScrollerFoundation2.prototype.handleTransitionEnd = function(evt) {
      var evtTarget = evt.target;
      if (!this.isAnimating || !this.adapter.eventTargetMatchesSelector(evtTarget, MDCTabScrollerFoundation2.strings.CONTENT_SELECTOR)) {
        return;
      }
      this.isAnimating = false;
      this.adapter.removeClass(MDCTabScrollerFoundation2.cssClasses.ANIMATING);
    };
    MDCTabScrollerFoundation2.prototype.incrementScroll = function(scrollXIncrement) {
      if (scrollXIncrement === 0) {
        return;
      }
      this.animate(this.getIncrementScrollOperation(scrollXIncrement));
    };
    MDCTabScrollerFoundation2.prototype.incrementScrollImmediate = function(scrollXIncrement) {
      if (scrollXIncrement === 0) {
        return;
      }
      var operation = this.getIncrementScrollOperation(scrollXIncrement);
      if (operation.scrollDelta === 0) {
        return;
      }
      this.stopScrollAnimation();
      this.adapter.setScrollAreaScrollLeft(operation.finalScrollPosition);
    };
    MDCTabScrollerFoundation2.prototype.scrollTo = function(scrollX) {
      if (this.isRTL()) {
        this.scrollToImplRTL(scrollX);
        return;
      }
      this.scrollToImpl(scrollX);
    };
    MDCTabScrollerFoundation2.prototype.getRTLScroller = function() {
      if (!this.rtlScrollerInstance) {
        this.rtlScrollerInstance = this.rtlScrollerFactory();
      }
      return this.rtlScrollerInstance;
    };
    MDCTabScrollerFoundation2.prototype.calculateCurrentTranslateX = function() {
      var transformValue = this.adapter.getScrollContentStyleValue("transform");
      if (transformValue === "none") {
        return 0;
      }
      var match = /\((.+?)\)/.exec(transformValue);
      if (!match) {
        return 0;
      }
      var matrixParams = match[1];
      var _a = __read(matrixParams.split(","), 6), a = _a[0], b = _a[1], c = _a[2], d = _a[3], tx = _a[4], ty = _a[5];
      return parseFloat(tx);
    };
    MDCTabScrollerFoundation2.prototype.clampScrollValue = function(scrollX) {
      var edges = this.calculateScrollEdges();
      return Math.min(Math.max(edges.left, scrollX), edges.right);
    };
    MDCTabScrollerFoundation2.prototype.computeCurrentScrollPositionRTL = function() {
      var translateX = this.calculateCurrentTranslateX();
      return this.getRTLScroller().getScrollPositionRTL(translateX);
    };
    MDCTabScrollerFoundation2.prototype.calculateScrollEdges = function() {
      var contentWidth = this.adapter.getScrollContentOffsetWidth();
      var rootWidth = this.adapter.getScrollAreaOffsetWidth();
      return {
        left: 0,
        right: contentWidth - rootWidth
      };
    };
    MDCTabScrollerFoundation2.prototype.scrollToImpl = function(scrollX) {
      var currentScrollX = this.getScrollPosition();
      var safeScrollX = this.clampScrollValue(scrollX);
      var scrollDelta = safeScrollX - currentScrollX;
      this.animate({
        finalScrollPosition: safeScrollX,
        scrollDelta
      });
    };
    MDCTabScrollerFoundation2.prototype.scrollToImplRTL = function(scrollX) {
      var animation = this.getRTLScroller().scrollToRTL(scrollX);
      this.animate(animation);
    };
    MDCTabScrollerFoundation2.prototype.getIncrementScrollOperation = function(scrollX) {
      if (this.isRTL()) {
        return this.getRTLScroller().incrementScrollRTL(scrollX);
      }
      var currentScrollX = this.getScrollPosition();
      var targetScrollX = scrollX + currentScrollX;
      var safeScrollX = this.clampScrollValue(targetScrollX);
      var scrollDelta = safeScrollX - currentScrollX;
      return {
        finalScrollPosition: safeScrollX,
        scrollDelta
      };
    };
    MDCTabScrollerFoundation2.prototype.animate = function(animation) {
      var _this = this;
      if (animation.scrollDelta === 0) {
        return;
      }
      this.stopScrollAnimation();
      this.adapter.setScrollAreaScrollLeft(animation.finalScrollPosition);
      this.adapter.setScrollContentStyleProperty("transform", "translateX(" + animation.scrollDelta + "px)");
      this.adapter.computeScrollAreaClientRect();
      requestAnimationFrame(function() {
        _this.adapter.addClass(MDCTabScrollerFoundation2.cssClasses.ANIMATING);
        _this.adapter.setScrollContentStyleProperty("transform", "none");
      });
      this.isAnimating = true;
    };
    MDCTabScrollerFoundation2.prototype.stopScrollAnimation = function() {
      this.isAnimating = false;
      var currentScrollPosition = this.getAnimatingScrollPosition();
      this.adapter.removeClass(MDCTabScrollerFoundation2.cssClasses.ANIMATING);
      this.adapter.setScrollContentStyleProperty("transform", "translateX(0px)");
      this.adapter.setScrollAreaScrollLeft(currentScrollPosition);
    };
    MDCTabScrollerFoundation2.prototype.getAnimatingScrollPosition = function() {
      var currentTranslateX = this.calculateCurrentTranslateX();
      var scrollLeft = this.adapter.getScrollAreaScrollLeft();
      if (this.isRTL()) {
        return this.getRTLScroller().getAnimatingScrollPosition(scrollLeft, currentTranslateX);
      }
      return scrollLeft - currentTranslateX;
    };
    MDCTabScrollerFoundation2.prototype.rtlScrollerFactory = function() {
      var initialScrollLeft = this.adapter.getScrollAreaScrollLeft();
      this.adapter.setScrollAreaScrollLeft(initialScrollLeft - 1);
      var newScrollLeft = this.adapter.getScrollAreaScrollLeft();
      if (newScrollLeft < 0) {
        this.adapter.setScrollAreaScrollLeft(initialScrollLeft);
        return new MDCTabScrollerRTLNegative(this.adapter);
      }
      var rootClientRect = this.adapter.computeScrollAreaClientRect();
      var contentClientRect = this.adapter.computeScrollContentClientRect();
      var rightEdgeDelta = Math.round(contentClientRect.right - rootClientRect.right);
      this.adapter.setScrollAreaScrollLeft(initialScrollLeft);
      if (rightEdgeDelta === newScrollLeft) {
        return new MDCTabScrollerRTLReverse(this.adapter);
      }
      return new MDCTabScrollerRTLDefault(this.adapter);
    };
    MDCTabScrollerFoundation2.prototype.isRTL = function() {
      return this.adapter.getScrollContentStyleValue("direction") === "rtl";
    };
    return MDCTabScrollerFoundation2;
  }(MDCFoundation)
);
var foundation_default = MDCTabScrollerFoundation;

// ../node_modules/@material/mwc-tab-scroller/mwc-tab-scroller-base.js
var TabScrollerBase = class extends BaseElement {
  constructor() {
    super(...arguments);
    this.mdcFoundationClass = foundation_default;
    this._scrollbarHeight = -1;
  }
  _handleInteraction() {
    this.mdcFoundation.handleInteraction();
  }
  _handleTransitionEnd(e) {
    this.mdcFoundation.handleTransitionEnd(e);
  }
  render() {
    return html`
      <div class="mdc-tab-scroller">
        <div class="mdc-tab-scroller__scroll-area"
            @wheel="${this._handleInteraction}"
            @touchstart="${this._handleInteraction}"
            @pointerdown="${this._handleInteraction}"
            @mousedown="${this._handleInteraction}"
            @keydown="${this._handleInteraction}"
            @transitionend="${this._handleTransitionEnd}">
          <div class="mdc-tab-scroller__scroll-content"><slot></slot></div>
        </div>
      </div>
      `;
  }
  createAdapter() {
    return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), { eventTargetMatchesSelector: (evtTarget, selector) => matches(evtTarget, selector), addScrollAreaClass: (className) => this.scrollAreaElement.classList.add(className), setScrollAreaStyleProperty: (prop, value) => this.scrollAreaElement.style.setProperty(prop, value), setScrollContentStyleProperty: (prop, value) => this.scrollContentElement.style.setProperty(prop, value), getScrollContentStyleValue: (propName) => window.getComputedStyle(this.scrollContentElement).getPropertyValue(propName), setScrollAreaScrollLeft: (scrollX) => this.scrollAreaElement.scrollLeft = scrollX, getScrollAreaScrollLeft: () => this.scrollAreaElement.scrollLeft, getScrollContentOffsetWidth: () => this.scrollContentElement.offsetWidth, getScrollAreaOffsetWidth: () => this.scrollAreaElement.offsetWidth, computeScrollAreaClientRect: () => this.scrollAreaElement.getBoundingClientRect(), computeScrollContentClientRect: () => this.scrollContentElement.getBoundingClientRect(), computeHorizontalScrollbarHeight: () => {
      if (this._scrollbarHeight === -1) {
        this.scrollAreaElement.style.overflowX = "scroll";
        this._scrollbarHeight = this.scrollAreaElement.offsetHeight - this.scrollAreaElement.clientHeight;
        this.scrollAreaElement.style.overflowX = "";
      }
      return this._scrollbarHeight;
    } });
  }
  /**
   * Returns the current visual scroll position
   * @return {number}
   */
  getScrollPosition() {
    return this.mdcFoundation.getScrollPosition();
  }
  /**
   * Returns the width of the scroll content
   * @return {number}
   */
  getScrollContentWidth() {
    return this.scrollContentElement.offsetWidth;
  }
  /**
   * Increments the scroll value by the given amount
   * @param {number} scrollXIncrement The pixel value by which to increment the
   *     scroll value
   */
  incrementScrollPosition(scrollXIncrement) {
    this.mdcFoundation.incrementScroll(scrollXIncrement);
  }
  /**
   * Scrolls to the given pixel position
   * @param {number} scrollX The pixel value to scroll to
   */
  scrollToPosition(scrollX) {
    this.mdcFoundation.scrollTo(scrollX);
  }
};
__decorate2([
  query(".mdc-tab-scroller")
], TabScrollerBase.prototype, "mdcRoot", void 0);
__decorate2([
  query(".mdc-tab-scroller__scroll-area")
], TabScrollerBase.prototype, "scrollAreaElement", void 0);
__decorate2([
  query(".mdc-tab-scroller__scroll-content")
], TabScrollerBase.prototype, "scrollContentElement", void 0);
__decorate2([
  eventOptions({ passive: true })
], TabScrollerBase.prototype, "_handleInteraction", null);

// ../node_modules/@material/mwc-tab-scroller/mwc-tab-scroller.css.js
var styles = css`.mdc-tab-scroller{overflow-y:hidden}.mdc-tab-scroller.mdc-tab-scroller--animating .mdc-tab-scroller__scroll-content{transition:250ms transform cubic-bezier(0.4, 0, 0.2, 1)}.mdc-tab-scroller__test{position:absolute;top:-9999px;width:100px;height:100px;overflow-x:scroll}.mdc-tab-scroller__scroll-area{-webkit-overflow-scrolling:touch;display:flex;overflow-x:hidden}.mdc-tab-scroller__scroll-area::-webkit-scrollbar,.mdc-tab-scroller__test::-webkit-scrollbar{display:none}.mdc-tab-scroller__scroll-area--scroll{overflow-x:scroll}.mdc-tab-scroller__scroll-content{position:relative;display:flex;flex:1 0 auto;transform:none;will-change:transform}.mdc-tab-scroller--align-start .mdc-tab-scroller__scroll-content{justify-content:flex-start}.mdc-tab-scroller--align-end .mdc-tab-scroller__scroll-content{justify-content:flex-end}.mdc-tab-scroller--align-center .mdc-tab-scroller__scroll-content{justify-content:center}.mdc-tab-scroller--animating .mdc-tab-scroller__scroll-area{-webkit-overflow-scrolling:auto}:host{display:flex}.mdc-tab-scroller{flex:1}`;

// ../node_modules/@material/mwc-tab-scroller/mwc-tab-scroller.js
var TabScroller = class TabScroller2 extends TabScrollerBase {
};
TabScroller.styles = [styles];
TabScroller = __decorate2([
  customElement("mwc-tab-scroller")
], TabScroller);

// ../node_modules/@material/tab-bar/node_modules/tslib/tslib.es6.mjs
var extendStatics2 = function(d, b) {
  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics2(d, b);
};
function __extends2(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics2(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign2 = function() {
  __assign2 = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};

// ../node_modules/@material/tab-bar/constants.js
var strings2 = {
  ARROW_LEFT_KEY: "ArrowLeft",
  ARROW_RIGHT_KEY: "ArrowRight",
  END_KEY: "End",
  ENTER_KEY: "Enter",
  HOME_KEY: "Home",
  SPACE_KEY: "Space",
  TAB_ACTIVATED_EVENT: "MDCTabBar:activated",
  TAB_SCROLLER_SELECTOR: ".mdc-tab-scroller",
  TAB_SELECTOR: ".mdc-tab"
};
var numbers = {
  ARROW_LEFT_KEYCODE: 37,
  ARROW_RIGHT_KEYCODE: 39,
  END_KEYCODE: 35,
  ENTER_KEYCODE: 13,
  EXTRA_SCROLL_AMOUNT: 20,
  HOME_KEYCODE: 36,
  SPACE_KEYCODE: 32
};

// ../node_modules/@material/tab-bar/foundation.js
var ACCEPTABLE_KEYS = /* @__PURE__ */ new Set();
ACCEPTABLE_KEYS.add(strings2.ARROW_LEFT_KEY);
ACCEPTABLE_KEYS.add(strings2.ARROW_RIGHT_KEY);
ACCEPTABLE_KEYS.add(strings2.END_KEY);
ACCEPTABLE_KEYS.add(strings2.HOME_KEY);
ACCEPTABLE_KEYS.add(strings2.ENTER_KEY);
ACCEPTABLE_KEYS.add(strings2.SPACE_KEY);
var KEYCODE_MAP = /* @__PURE__ */ new Map();
KEYCODE_MAP.set(numbers.ARROW_LEFT_KEYCODE, strings2.ARROW_LEFT_KEY);
KEYCODE_MAP.set(numbers.ARROW_RIGHT_KEYCODE, strings2.ARROW_RIGHT_KEY);
KEYCODE_MAP.set(numbers.END_KEYCODE, strings2.END_KEY);
KEYCODE_MAP.set(numbers.HOME_KEYCODE, strings2.HOME_KEY);
KEYCODE_MAP.set(numbers.ENTER_KEYCODE, strings2.ENTER_KEY);
KEYCODE_MAP.set(numbers.SPACE_KEYCODE, strings2.SPACE_KEY);
var MDCTabBarFoundation = (
  /** @class */
  function(_super) {
    __extends2(MDCTabBarFoundation2, _super);
    function MDCTabBarFoundation2(adapter) {
      var _this = _super.call(this, __assign2(__assign2({}, MDCTabBarFoundation2.defaultAdapter), adapter)) || this;
      _this.useAutomaticActivation = false;
      return _this;
    }
    Object.defineProperty(MDCTabBarFoundation2, "strings", {
      get: function() {
        return strings2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTabBarFoundation2, "numbers", {
      get: function() {
        return numbers;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTabBarFoundation2, "defaultAdapter", {
      get: function() {
        return {
          scrollTo: function() {
            return void 0;
          },
          incrementScroll: function() {
            return void 0;
          },
          getScrollPosition: function() {
            return 0;
          },
          getScrollContentWidth: function() {
            return 0;
          },
          getOffsetWidth: function() {
            return 0;
          },
          isRTL: function() {
            return false;
          },
          setActiveTab: function() {
            return void 0;
          },
          activateTabAtIndex: function() {
            return void 0;
          },
          deactivateTabAtIndex: function() {
            return void 0;
          },
          focusTabAtIndex: function() {
            return void 0;
          },
          getTabIndicatorClientRectAtIndex: function() {
            return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
          },
          getTabDimensionsAtIndex: function() {
            return { rootLeft: 0, rootRight: 0, contentLeft: 0, contentRight: 0 };
          },
          getPreviousActiveTabIndex: function() {
            return -1;
          },
          getFocusedTabIndex: function() {
            return -1;
          },
          getIndexOfTabById: function() {
            return -1;
          },
          getTabListLength: function() {
            return 0;
          },
          notifyTabActivated: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCTabBarFoundation2.prototype.setUseAutomaticActivation = function(useAutomaticActivation) {
      this.useAutomaticActivation = useAutomaticActivation;
    };
    MDCTabBarFoundation2.prototype.activateTab = function(index) {
      var previousActiveIndex = this.adapter.getPreviousActiveTabIndex();
      if (!this.indexIsInRange(index) || index === previousActiveIndex) {
        return;
      }
      var previousClientRect;
      if (previousActiveIndex !== -1) {
        this.adapter.deactivateTabAtIndex(previousActiveIndex);
        previousClientRect = this.adapter.getTabIndicatorClientRectAtIndex(previousActiveIndex);
      }
      this.adapter.activateTabAtIndex(index, previousClientRect);
      this.scrollIntoView(index);
      this.adapter.notifyTabActivated(index);
    };
    MDCTabBarFoundation2.prototype.handleKeyDown = function(evt) {
      var key = this.getKeyFromEvent(evt);
      if (key === void 0) {
        return;
      }
      if (!this.isActivationKey(key)) {
        evt.preventDefault();
      }
      if (this.useAutomaticActivation) {
        if (this.isActivationKey(key)) {
          return;
        }
        var index = this.determineTargetFromKey(this.adapter.getPreviousActiveTabIndex(), key);
        this.adapter.setActiveTab(index);
        this.scrollIntoView(index);
      } else {
        var focusedTabIndex = this.adapter.getFocusedTabIndex();
        if (this.isActivationKey(key)) {
          this.adapter.setActiveTab(focusedTabIndex);
        } else {
          var index = this.determineTargetFromKey(focusedTabIndex, key);
          this.adapter.focusTabAtIndex(index);
          this.scrollIntoView(index);
        }
      }
    };
    MDCTabBarFoundation2.prototype.handleTabInteraction = function(evt) {
      this.adapter.setActiveTab(this.adapter.getIndexOfTabById(evt.detail.tabId));
    };
    MDCTabBarFoundation2.prototype.scrollIntoView = function(index) {
      if (!this.indexIsInRange(index)) {
        return;
      }
      if (index === 0) {
        this.adapter.scrollTo(0);
        return;
      }
      if (index === this.adapter.getTabListLength() - 1) {
        this.adapter.scrollTo(this.adapter.getScrollContentWidth());
        return;
      }
      if (this.isRTL()) {
        this.scrollIntoViewImplRTL(index);
        return;
      }
      this.scrollIntoViewImpl(index);
    };
    MDCTabBarFoundation2.prototype.determineTargetFromKey = function(origin, key) {
      var isRTL = this.isRTL();
      var maxIndex = this.adapter.getTabListLength() - 1;
      var shouldGoToEnd = key === strings2.END_KEY;
      var shouldDecrement = key === strings2.ARROW_LEFT_KEY && !isRTL || key === strings2.ARROW_RIGHT_KEY && isRTL;
      var shouldIncrement = key === strings2.ARROW_RIGHT_KEY && !isRTL || key === strings2.ARROW_LEFT_KEY && isRTL;
      var index = origin;
      if (shouldGoToEnd) {
        index = maxIndex;
      } else if (shouldDecrement) {
        index -= 1;
      } else if (shouldIncrement) {
        index += 1;
      } else {
        index = 0;
      }
      if (index < 0) {
        index = maxIndex;
      } else if (index > maxIndex) {
        index = 0;
      }
      return index;
    };
    MDCTabBarFoundation2.prototype.calculateScrollIncrement = function(index, nextIndex, scrollPosition, barWidth) {
      var nextTabDimensions = this.adapter.getTabDimensionsAtIndex(nextIndex);
      var relativeContentLeft = nextTabDimensions.contentLeft - scrollPosition - barWidth;
      var relativeContentRight = nextTabDimensions.contentRight - scrollPosition;
      var leftIncrement = relativeContentRight - numbers.EXTRA_SCROLL_AMOUNT;
      var rightIncrement = relativeContentLeft + numbers.EXTRA_SCROLL_AMOUNT;
      if (nextIndex < index) {
        return Math.min(leftIncrement, 0);
      }
      return Math.max(rightIncrement, 0);
    };
    MDCTabBarFoundation2.prototype.calculateScrollIncrementRTL = function(index, nextIndex, scrollPosition, barWidth, scrollContentWidth) {
      var nextTabDimensions = this.adapter.getTabDimensionsAtIndex(nextIndex);
      var relativeContentLeft = scrollContentWidth - nextTabDimensions.contentLeft - scrollPosition;
      var relativeContentRight = scrollContentWidth - nextTabDimensions.contentRight - scrollPosition - barWidth;
      var leftIncrement = relativeContentRight + numbers.EXTRA_SCROLL_AMOUNT;
      var rightIncrement = relativeContentLeft - numbers.EXTRA_SCROLL_AMOUNT;
      if (nextIndex > index) {
        return Math.max(leftIncrement, 0);
      }
      return Math.min(rightIncrement, 0);
    };
    MDCTabBarFoundation2.prototype.findAdjacentTabIndexClosestToEdge = function(index, tabDimensions, scrollPosition, barWidth) {
      var relativeRootLeft = tabDimensions.rootLeft - scrollPosition;
      var relativeRootRight = tabDimensions.rootRight - scrollPosition - barWidth;
      var relativeRootDelta = relativeRootLeft + relativeRootRight;
      var leftEdgeIsCloser = relativeRootLeft < 0 || relativeRootDelta < 0;
      var rightEdgeIsCloser = relativeRootRight > 0 || relativeRootDelta > 0;
      if (leftEdgeIsCloser) {
        return index - 1;
      }
      if (rightEdgeIsCloser) {
        return index + 1;
      }
      return -1;
    };
    MDCTabBarFoundation2.prototype.findAdjacentTabIndexClosestToEdgeRTL = function(index, tabDimensions, scrollPosition, barWidth, scrollContentWidth) {
      var rootLeft = scrollContentWidth - tabDimensions.rootLeft - barWidth - scrollPosition;
      var rootRight = scrollContentWidth - tabDimensions.rootRight - scrollPosition;
      var rootDelta = rootLeft + rootRight;
      var leftEdgeIsCloser = rootLeft > 0 || rootDelta > 0;
      var rightEdgeIsCloser = rootRight < 0 || rootDelta < 0;
      if (leftEdgeIsCloser) {
        return index + 1;
      }
      if (rightEdgeIsCloser) {
        return index - 1;
      }
      return -1;
    };
    MDCTabBarFoundation2.prototype.getKeyFromEvent = function(evt) {
      if (ACCEPTABLE_KEYS.has(evt.key)) {
        return evt.key;
      }
      return KEYCODE_MAP.get(evt.keyCode);
    };
    MDCTabBarFoundation2.prototype.isActivationKey = function(key) {
      return key === strings2.SPACE_KEY || key === strings2.ENTER_KEY;
    };
    MDCTabBarFoundation2.prototype.indexIsInRange = function(index) {
      return index >= 0 && index < this.adapter.getTabListLength();
    };
    MDCTabBarFoundation2.prototype.isRTL = function() {
      return this.adapter.isRTL();
    };
    MDCTabBarFoundation2.prototype.scrollIntoViewImpl = function(index) {
      var scrollPosition = this.adapter.getScrollPosition();
      var barWidth = this.adapter.getOffsetWidth();
      var tabDimensions = this.adapter.getTabDimensionsAtIndex(index);
      var nextIndex = this.findAdjacentTabIndexClosestToEdge(index, tabDimensions, scrollPosition, barWidth);
      if (!this.indexIsInRange(nextIndex)) {
        return;
      }
      var scrollIncrement = this.calculateScrollIncrement(index, nextIndex, scrollPosition, barWidth);
      this.adapter.incrementScroll(scrollIncrement);
    };
    MDCTabBarFoundation2.prototype.scrollIntoViewImplRTL = function(index) {
      var scrollPosition = this.adapter.getScrollPosition();
      var barWidth = this.adapter.getOffsetWidth();
      var tabDimensions = this.adapter.getTabDimensionsAtIndex(index);
      var scrollWidth = this.adapter.getScrollContentWidth();
      var nextIndex = this.findAdjacentTabIndexClosestToEdgeRTL(index, tabDimensions, scrollPosition, barWidth, scrollWidth);
      if (!this.indexIsInRange(nextIndex)) {
        return;
      }
      var scrollIncrement = this.calculateScrollIncrementRTL(index, nextIndex, scrollPosition, barWidth, scrollWidth);
      this.adapter.incrementScroll(scrollIncrement);
    };
    return MDCTabBarFoundation2;
  }(MDCFoundation)
);
var foundation_default2 = MDCTabBarFoundation;

// ../node_modules/@material/mwc-tab-bar/mwc-tab-bar-base.js
var TabBarBase = class extends BaseElement {
  constructor() {
    super(...arguments);
    this.mdcFoundationClass = foundation_default2;
    this.activeIndex = 0;
    this._previousActiveIndex = -1;
  }
  _handleTabInteraction(e) {
    this.mdcFoundation.handleTabInteraction(e);
  }
  _handleKeydown(e) {
    this.mdcFoundation.handleKeyDown(e);
  }
  // TODO(sorvell): can scroller be optional for perf?
  render() {
    return html`
      <div class="mdc-tab-bar" role="tablist"
          @MDCTab:interacted="${this._handleTabInteraction}"
          @keydown="${this._handleKeydown}">
        <mwc-tab-scroller><slot></slot></mwc-tab-scroller>
      </div>
      `;
  }
  // TODO(sorvell): probably want to memoize this and use a `slotChange` event
  _getTabs() {
    return this.tabsSlot.assignedNodes({ flatten: true }).filter((e) => e instanceof TabBase);
  }
  _getTab(index) {
    return this._getTabs()[index];
  }
  createAdapter() {
    return {
      scrollTo: (scrollX) => this.scrollerElement.scrollToPosition(scrollX),
      incrementScroll: (scrollXIncrement) => this.scrollerElement.incrementScrollPosition(scrollXIncrement),
      getScrollPosition: () => this.scrollerElement.getScrollPosition(),
      getScrollContentWidth: () => this.scrollerElement.getScrollContentWidth(),
      getOffsetWidth: () => this.mdcRoot.offsetWidth,
      isRTL: () => window.getComputedStyle(this.mdcRoot).getPropertyValue("direction") === "rtl",
      setActiveTab: (index) => this.mdcFoundation.activateTab(index),
      activateTabAtIndex: (index, clientRect) => {
        const tab = this._getTab(index);
        if (tab !== void 0) {
          tab.activate(clientRect);
        }
        this._previousActiveIndex = index;
      },
      deactivateTabAtIndex: (index) => {
        const tab = this._getTab(index);
        if (tab !== void 0) {
          tab.deactivate();
        }
      },
      focusTabAtIndex: (index) => {
        const tab = this._getTab(index);
        if (tab !== void 0) {
          tab.focus();
        }
      },
      // TODO(sorvell): tab may not be able to synchronously answer
      // `computeIndicatorClientRect` if an update is pending or it has not yet
      // updated. If this is necessary, LitElement may need a `forceUpdate`
      // method.
      getTabIndicatorClientRectAtIndex: (index) => {
        const tab = this._getTab(index);
        return tab !== void 0 ? tab.computeIndicatorClientRect() : new DOMRect();
      },
      getTabDimensionsAtIndex: (index) => {
        const tab = this._getTab(index);
        return tab !== void 0 ? tab.computeDimensions() : { rootLeft: 0, rootRight: 0, contentLeft: 0, contentRight: 0 };
      },
      getPreviousActiveTabIndex: () => {
        return this._previousActiveIndex;
      },
      getFocusedTabIndex: () => {
        const tabElements = this._getTabs();
        const activeElement = this.getRootNode().activeElement;
        return tabElements.indexOf(activeElement);
      },
      getIndexOfTabById: (id) => {
        const tabElements = this._getTabs();
        for (let i = 0; i < tabElements.length; i++) {
          if (tabElements[i].id === id) {
            return i;
          }
        }
        return -1;
      },
      getTabListLength: () => this._getTabs().length,
      notifyTabActivated: (index) => {
        this.activeIndex = index;
        this.dispatchEvent(new CustomEvent(foundation_default2.strings.TAB_ACTIVATED_EVENT, { detail: { index }, bubbles: true, cancelable: true }));
      }
    };
  }
  firstUpdated() {
  }
  async getUpdateComplete() {
    const result = await super.getUpdateComplete();
    await this.scrollerElement.updateComplete;
    if (this.mdcFoundation === void 0) {
      this.createFoundation();
    }
    return result;
  }
  scrollIndexIntoView(index) {
    this.mdcFoundation.scrollIntoView(index);
  }
};
__decorate([
  query(".mdc-tab-bar")
], TabBarBase.prototype, "mdcRoot", void 0);
__decorate([
  query("mwc-tab-scroller")
], TabBarBase.prototype, "scrollerElement", void 0);
__decorate([
  query("slot")
], TabBarBase.prototype, "tabsSlot", void 0);
__decorate([
  observer(async function() {
    await this.updateComplete;
    if (this.activeIndex !== this._previousActiveIndex) {
      this.mdcFoundation.activateTab(this.activeIndex);
    }
  }),
  property({ type: Number })
], TabBarBase.prototype, "activeIndex", void 0);

// ../node_modules/@material/mwc-tab-bar/mwc-tab-bar.css.js
var styles2 = css`.mdc-tab-bar{width:100%}.mdc-tab{height:48px}.mdc-tab--stacked{height:72px}:host{display:block}.mdc-tab-bar{flex:1}mwc-tab{--mdc-tab-height: 48px;--mdc-tab-stacked-height: 72px}`;

// ../node_modules/@material/mwc-tab-bar/mwc-tab-bar.js
var TabBar = class TabBar2 extends TabBarBase {
};
TabBar.styles = [styles2];
TabBar = __decorate([
  customElement("mwc-tab-bar")
], TabBar);
export {
  TabBar
};
/*! Bundled license information:

@material/tab-scroller/constants.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/tab-scroller/rtl-scroller.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/tab-scroller/rtl-default-scroller.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/tab-scroller/rtl-negative-scroller.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/tab-scroller/rtl-reverse-scroller.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/tab-scroller/foundation.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/mwc-tab-scroller/mwc-tab-scroller-base.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

@material/mwc-tab-scroller/mwc-tab-scroller.css.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-LIcense-Identifier: Apache-2.0
   *)

@material/mwc-tab-scroller/mwc-tab-scroller.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

@material/tab-bar/constants.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/tab-bar/foundation.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/mwc-tab-bar/mwc-tab-bar-base.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

@material/mwc-tab-bar/mwc-tab-bar.css.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-LIcense-Identifier: Apache-2.0
   *)

@material/mwc-tab-bar/mwc-tab-bar.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=@material_mwc-tab-bar.js.map
