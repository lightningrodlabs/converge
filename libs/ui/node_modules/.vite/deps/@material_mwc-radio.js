import {
  observer
} from "./chunk-3RT6BUHN.js";
import {
  FormElement
} from "./chunk-BJ2UCMSJ.js";
import {
  RippleHandlers
} from "./chunk-MZAI3YEV.js";
import {
  ariaProperty
} from "./chunk-EGZDDV6L.js";
import "./chunk-QBLXO4ZU.js";
import "./chunk-WQJA2ZTO.js";
import {
  ifDefined
} from "./chunk-3UHMJHWB.js";
import {
  MDCFoundation,
  addHasRemoveClass
} from "./chunk-K2GWU6W5.js";
import {
  classMap
} from "./chunk-XHTW3CQQ.js";
import {
  customElement,
  eventOptions,
  property,
  query,
  queryAsync,
  state
} from "./chunk-LLKFEKJC.js";
import {
  html
} from "./chunk-KJJ2SZCS.js";
import "./chunk-HKTNVJXR.js";
import {
  css
} from "./chunk-QK5UQRR6.js";
import "./chunk-TCQZMY3T.js";

// ../node_modules/@material/mwc-radio/node_modules/tslib/tslib.es6.js
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// ../node_modules/@material/mwc-radio/single-selection-controller.js
var selectionController = Symbol("selection controller");
var SingleSelectionSet = class {
  constructor() {
    this.selected = null;
    this.ordered = null;
    this.set = /* @__PURE__ */ new Set();
  }
};
var SingleSelectionController = class _SingleSelectionController {
  constructor(element) {
    this.sets = {};
    this.focusedSet = null;
    this.mouseIsDown = false;
    this.updating = false;
    element.addEventListener("keydown", (e) => {
      this.keyDownHandler(e);
    });
    element.addEventListener("mousedown", () => {
      this.mousedownHandler();
    });
    element.addEventListener("mouseup", () => {
      this.mouseupHandler();
    });
  }
  /**
   * Get a controller for the given element. If no controller exists, one will
   * be created. Defaults to getting the controller scoped to the element's root
   * node shadow root unless `element.global` is true. Then, it will get a
   * `window.document`-scoped controller.
   *
   * @param element Element from which to get / create a SelectionController. If
   *     `element.global` is true, it gets a selection controller scoped to
   *     `window.document`.
   */
  static getController(element) {
    const useGlobal = !("global" in element) || "global" in element && element.global;
    const root = useGlobal ? document : element.getRootNode();
    let controller = root[selectionController];
    if (controller === void 0) {
      controller = new _SingleSelectionController(root);
      root[selectionController] = controller;
    }
    return controller;
  }
  keyDownHandler(e) {
    const element = e.target;
    if (!("checked" in element)) {
      return;
    }
    if (!this.has(element)) {
      return;
    }
    if (e.key == "ArrowRight" || e.key == "ArrowDown") {
      this.selectNext(element);
    } else if (e.key == "ArrowLeft" || e.key == "ArrowUp") {
      this.selectPrevious(element);
    }
  }
  mousedownHandler() {
    this.mouseIsDown = true;
  }
  mouseupHandler() {
    this.mouseIsDown = false;
  }
  /**
   * Whether or not the controller controls  the given element.
   *
   * @param element element to check
   */
  has(element) {
    const set = this.getSet(element.name);
    return set.set.has(element);
  }
  /**
   * Selects and returns the controlled element previous to the given element in
   * document position order. See
   * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).
   *
   * @param element element relative from which preceding element is fetched
   */
  selectPrevious(element) {
    const order = this.getOrdered(element);
    const i = order.indexOf(element);
    const previous = order[i - 1] || order[order.length - 1];
    this.select(previous);
    return previous;
  }
  /**
   * Selects and returns the controlled element next to the given element in
   * document position order. See
   * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).
   *
   * @param element element relative from which following element is fetched
   */
  selectNext(element) {
    const order = this.getOrdered(element);
    const i = order.indexOf(element);
    const next = order[i + 1] || order[0];
    this.select(next);
    return next;
  }
  select(element) {
    element.click();
  }
  /**
   * Focuses the selected element in the given element's selection set. User's
   * mouse selection will override this focus.
   *
   * @param element Element from which selection set is derived and subsequently
   *     focused.
   * @deprecated update() method now handles focus management by setting
   *     appropriate tabindex to form element.
   */
  focus(element) {
    if (this.mouseIsDown) {
      return;
    }
    const set = this.getSet(element.name);
    const currentFocusedSet = this.focusedSet;
    this.focusedSet = set;
    if (currentFocusedSet != set && set.selected && set.selected != element) {
      set.selected.focus();
    }
  }
  /**
   * @return Returns true if atleast one radio is selected in the radio group.
   */
  isAnySelected(element) {
    const set = this.getSet(element.name);
    for (const e of set.set) {
      if (e.checked) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns the elements in the given element's selection set in document
   * position order.
   * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).
   *
   * @param element Element from which selection set is derived and subsequently
   *     ordered.
   */
  getOrdered(element) {
    const set = this.getSet(element.name);
    if (!set.ordered) {
      set.ordered = Array.from(set.set);
      set.ordered.sort((a, b) => a.compareDocumentPosition(b) == Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0);
    }
    return set.ordered;
  }
  /**
   * Gets the selection set of the given name and creates one if it does not yet
   * exist.
   *
   * @param name Name of set
   */
  getSet(name) {
    if (!this.sets[name]) {
      this.sets[name] = new SingleSelectionSet();
    }
    return this.sets[name];
  }
  /**
   * Register the element in the selection controller.
   *
   * @param element Element to register. Registers in set of `element.name`.
   */
  register(element) {
    const name = element.name || element.getAttribute("name") || "";
    const set = this.getSet(name);
    set.set.add(element);
    set.ordered = null;
  }
  /**
   * Unregister the element from selection controller.
   *
   * @param element Element to register. Registers in set of `element.name`.
   */
  unregister(element) {
    const set = this.getSet(element.name);
    set.set.delete(element);
    set.ordered = null;
    if (set.selected == element) {
      set.selected = null;
    }
  }
  /**
   * Unselects other elements in element's set if element is checked. Noop
   * otherwise.
   *
   * @param element Element from which to calculate selection controller update.
   */
  update(element) {
    if (this.updating) {
      return;
    }
    this.updating = true;
    const set = this.getSet(element.name);
    if (element.checked) {
      for (const e of set.set) {
        if (e == element) {
          continue;
        }
        e.checked = false;
      }
      set.selected = element;
    }
    if (this.isAnySelected(element)) {
      for (const e of set.set) {
        if (e.formElementTabIndex === void 0) {
          break;
        }
        e.formElementTabIndex = e.checked ? 0 : -1;
      }
    }
    this.updating = false;
  }
};

// ../node_modules/@material/radio/node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};

// ../node_modules/@material/radio/constants.js
var strings = {
  NATIVE_CONTROL_SELECTOR: ".mdc-radio__native-control"
};
var cssClasses = {
  DISABLED: "mdc-radio--disabled",
  ROOT: "mdc-radio"
};

// ../node_modules/@material/radio/foundation.js
var MDCRadioFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCRadioFoundation2, _super);
    function MDCRadioFoundation2(adapter) {
      return _super.call(this, __assign(__assign({}, MDCRadioFoundation2.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCRadioFoundation2, "cssClasses", {
      get: function() {
        return cssClasses;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRadioFoundation2, "strings", {
      get: function() {
        return strings;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRadioFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          setNativeControlDisabled: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCRadioFoundation2.prototype.setDisabled = function(disabled) {
      var DISABLED = MDCRadioFoundation2.cssClasses.DISABLED;
      this.adapter.setNativeControlDisabled(disabled);
      if (disabled) {
        this.adapter.addClass(DISABLED);
      } else {
        this.adapter.removeClass(DISABLED);
      }
    };
    return MDCRadioFoundation2;
  }(MDCFoundation)
);
var foundation_default = MDCRadioFoundation;

// ../node_modules/@material/mwc-radio/mwc-radio-base.js
var RadioBase = class extends FormElement {
  constructor() {
    super(...arguments);
    this._checked = false;
    this.useStateLayerCustomProperties = false;
    this.global = false;
    this.disabled = false;
    this.value = "on";
    this.name = "";
    this.reducedTouchTarget = false;
    this.mdcFoundationClass = foundation_default;
    this.formElementTabIndex = 0;
    this.focused = false;
    this.shouldRenderRipple = false;
    this.rippleElement = null;
    this.rippleHandlers = new RippleHandlers(() => {
      this.shouldRenderRipple = true;
      this.ripple.then((v) => {
        this.rippleElement = v;
      });
      return this.ripple;
    });
  }
  get checked() {
    return this._checked;
  }
  /**
   * We define our own getter/setter for `checked` because we need to track
   * changes to it synchronously.
   *
   * The order in which the `checked` property is set across radio buttons
   * within the same group is very important. However, we can't rely on
   * UpdatingElement's `updated` callback to observe these changes (which is
   * also what the `@observer` decorator uses), because it batches changes to
   * all properties.
   *
   * Consider:
   *
   *   radio1.disabled = true;
   *   radio2.checked = true;
   *   radio1.checked = true;
   *
   * In this case we'd first see all changes for radio1, and then for radio2,
   * and we couldn't tell that radio1 was the most recently checked.
   */
  set checked(isChecked) {
    var _a, _b;
    const oldValue = this._checked;
    if (isChecked === oldValue) {
      return;
    }
    this._checked = isChecked;
    if (this.formElement) {
      this.formElement.checked = isChecked;
    }
    (_a = this._selectionController) === null || _a === void 0 ? void 0 : _a.update(this);
    if (isChecked === false) {
      (_b = this.formElement) === null || _b === void 0 ? void 0 : _b.blur();
    }
    this.requestUpdate("checked", oldValue);
    this.dispatchEvent(new Event("checked", { bubbles: true, composed: true }));
  }
  _handleUpdatedValue(newValue) {
    this.formElement.value = newValue;
  }
  /** @soyTemplate */
  renderRipple() {
    return this.shouldRenderRipple ? html`<mwc-ripple unbounded accent
        .internalUseStateLayerCustomProperties="${this.useStateLayerCustomProperties}"
        .disabled="${this.disabled}"></mwc-ripple>` : "";
  }
  get isRippleActive() {
    var _a;
    return ((_a = this.rippleElement) === null || _a === void 0 ? void 0 : _a.isActive) || false;
  }
  connectedCallback() {
    super.connectedCallback();
    this._selectionController = SingleSelectionController.getController(this);
    this._selectionController.register(this);
    this._selectionController.update(this);
  }
  disconnectedCallback() {
    this._selectionController.unregister(this);
    this._selectionController = void 0;
  }
  focus() {
    this.formElement.focus();
  }
  createAdapter() {
    return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), { setNativeControlDisabled: (disabled) => {
      this.formElement.disabled = disabled;
    } });
  }
  handleFocus() {
    this.focused = true;
    this.handleRippleFocus();
  }
  handleClick() {
    this.formElement.focus();
  }
  handleBlur() {
    this.focused = false;
    this.formElement.blur();
    this.rippleHandlers.endFocus();
  }
  setFormData(formData) {
    if (this.name && this.checked) {
      formData.append(this.name, this.value);
    }
  }
  /**
   * @soyTemplate
   * @soyAttributes radioAttributes: input
   * @soyClasses radioClasses: .mdc-radio
   */
  render() {
    const classes = {
      "mdc-radio--touch": !this.reducedTouchTarget,
      "mdc-ripple-upgraded--background-focused": this.focused,
      "mdc-radio--disabled": this.disabled
    };
    return html`
      <div class="mdc-radio ${classMap(classes)}">
        <input
          tabindex="${this.formElementTabIndex}"
          class="mdc-radio__native-control"
          type="radio"
          name="${this.name}"
          aria-label="${ifDefined(this.ariaLabel)}"
          aria-labelledby="${ifDefined(this.ariaLabelledBy)}"
          .checked="${this.checked}"
          .value="${this.value}"
          ?disabled="${this.disabled}"
          @change="${this.changeHandler}"
          @focus="${this.handleFocus}"
          @click="${this.handleClick}"
          @blur="${this.handleBlur}"
          @mousedown="${this.handleRippleMouseDown}"
          @mouseenter="${this.handleRippleMouseEnter}"
          @mouseleave="${this.handleRippleMouseLeave}"
          @touchstart="${this.handleRippleTouchStart}"
          @touchend="${this.handleRippleDeactivate}"
          @touchcancel="${this.handleRippleDeactivate}">
        <div class="mdc-radio__background">
          <div class="mdc-radio__outer-circle"></div>
          <div class="mdc-radio__inner-circle"></div>
        </div>
        ${this.renderRipple()}
      </div>`;
  }
  handleRippleMouseDown(event) {
    const onUp = () => {
      window.removeEventListener("mouseup", onUp);
      this.handleRippleDeactivate();
    };
    window.addEventListener("mouseup", onUp);
    this.rippleHandlers.startPress(event);
  }
  handleRippleTouchStart(event) {
    this.rippleHandlers.startPress(event);
  }
  handleRippleDeactivate() {
    this.rippleHandlers.endPress();
  }
  handleRippleMouseEnter() {
    this.rippleHandlers.startHover();
  }
  handleRippleMouseLeave() {
    this.rippleHandlers.endHover();
  }
  handleRippleFocus() {
    this.rippleHandlers.startFocus();
  }
  changeHandler() {
    this.checked = this.formElement.checked;
  }
};
__decorate([
  query(".mdc-radio")
], RadioBase.prototype, "mdcRoot", void 0);
__decorate([
  query("input")
], RadioBase.prototype, "formElement", void 0);
__decorate([
  state()
], RadioBase.prototype, "useStateLayerCustomProperties", void 0);
__decorate([
  property({ type: Boolean })
], RadioBase.prototype, "global", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], RadioBase.prototype, "checked", null);
__decorate([
  property({ type: Boolean }),
  observer(function(disabled) {
    this.mdcFoundation.setDisabled(disabled);
  })
], RadioBase.prototype, "disabled", void 0);
__decorate([
  property({ type: String }),
  observer(function(value) {
    this._handleUpdatedValue(value);
  })
], RadioBase.prototype, "value", void 0);
__decorate([
  property({ type: String })
], RadioBase.prototype, "name", void 0);
__decorate([
  property({ type: Boolean })
], RadioBase.prototype, "reducedTouchTarget", void 0);
__decorate([
  property({ type: Number })
], RadioBase.prototype, "formElementTabIndex", void 0);
__decorate([
  state()
], RadioBase.prototype, "focused", void 0);
__decorate([
  state()
], RadioBase.prototype, "shouldRenderRipple", void 0);
__decorate([
  queryAsync("mwc-ripple")
], RadioBase.prototype, "ripple", void 0);
__decorate([
  ariaProperty,
  property({ attribute: "aria-label" })
], RadioBase.prototype, "ariaLabel", void 0);
__decorate([
  ariaProperty,
  property({ attribute: "aria-labelledby" })
], RadioBase.prototype, "ariaLabelledBy", void 0);
__decorate([
  eventOptions({ passive: true })
], RadioBase.prototype, "handleRippleTouchStart", null);

// ../node_modules/@material/mwc-radio/mwc-radio.css.js
var styles = css`.mdc-touch-target-wrapper{display:inline}.mdc-radio{padding:calc((40px - 20px) / 2)}.mdc-radio .mdc-radio__native-control:enabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{border-color:rgba(0, 0, 0, 0.54)}.mdc-radio .mdc-radio__native-control:enabled:checked+.mdc-radio__background .mdc-radio__outer-circle{border-color:#018786;border-color:var(--mdc-theme-secondary, #018786)}.mdc-radio .mdc-radio__native-control:enabled+.mdc-radio__background .mdc-radio__inner-circle{border-color:#018786;border-color:var(--mdc-theme-secondary, #018786)}.mdc-radio [aria-disabled=true] .mdc-radio__native-control:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle,.mdc-radio .mdc-radio__native-control:disabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{border-color:rgba(0, 0, 0, 0.38)}.mdc-radio [aria-disabled=true] .mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__outer-circle,.mdc-radio .mdc-radio__native-control:disabled:checked+.mdc-radio__background .mdc-radio__outer-circle{border-color:rgba(0, 0, 0, 0.38)}.mdc-radio [aria-disabled=true] .mdc-radio__native-control+.mdc-radio__background .mdc-radio__inner-circle,.mdc-radio .mdc-radio__native-control:disabled+.mdc-radio__background .mdc-radio__inner-circle{border-color:rgba(0, 0, 0, 0.38)}.mdc-radio .mdc-radio__background::before{background-color:#018786;background-color:var(--mdc-theme-secondary, #018786)}.mdc-radio .mdc-radio__background::before{top:calc(-1 * (40px - 20px) / 2);left:calc(-1 * (40px - 20px) / 2);width:40px;height:40px}.mdc-radio .mdc-radio__native-control{top:calc((40px - 40px) / 2);right:calc((40px - 40px) / 2);left:calc((40px - 40px) / 2);width:40px;height:40px}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-radio.mdc-radio--disabled [aria-disabled=true] .mdc-radio__native-control:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle,.mdc-radio.mdc-radio--disabled .mdc-radio__native-control:disabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{border-color:GrayText}.mdc-radio.mdc-radio--disabled [aria-disabled=true] .mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__outer-circle,.mdc-radio.mdc-radio--disabled .mdc-radio__native-control:disabled:checked+.mdc-radio__background .mdc-radio__outer-circle{border-color:GrayText}.mdc-radio.mdc-radio--disabled [aria-disabled=true] .mdc-radio__native-control+.mdc-radio__background .mdc-radio__inner-circle,.mdc-radio.mdc-radio--disabled .mdc-radio__native-control:disabled+.mdc-radio__background .mdc-radio__inner-circle{border-color:GrayText}}.mdc-radio{display:inline-block;position:relative;flex:0 0 auto;box-sizing:content-box;width:20px;height:20px;cursor:pointer;will-change:opacity,transform,border-color,color}.mdc-radio__background{display:inline-block;position:relative;box-sizing:border-box;width:20px;height:20px}.mdc-radio__background::before{position:absolute;transform:scale(0, 0);border-radius:50%;opacity:0;pointer-events:none;content:"";transition:opacity 120ms 0ms cubic-bezier(0.4, 0, 0.6, 1),transform 120ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-radio__outer-circle{position:absolute;top:0;left:0;box-sizing:border-box;width:100%;height:100%;border-width:2px;border-style:solid;border-radius:50%;transition:border-color 120ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-radio__inner-circle{position:absolute;top:0;left:0;box-sizing:border-box;width:100%;height:100%;transform:scale(0, 0);border-width:10px;border-style:solid;border-radius:50%;transition:transform 120ms 0ms cubic-bezier(0.4, 0, 0.6, 1),border-color 120ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-radio__native-control{position:absolute;margin:0;padding:0;opacity:0;cursor:inherit;z-index:1}.mdc-radio--touch{margin-top:4px;margin-bottom:4px;margin-right:4px;margin-left:4px}.mdc-radio--touch .mdc-radio__native-control{top:calc((40px - 48px) / 2);right:calc((40px - 48px) / 2);left:calc((40px - 48px) / 2);width:48px;height:48px}.mdc-radio.mdc-ripple-upgraded--background-focused .mdc-radio__focus-ring,.mdc-radio:not(.mdc-ripple-upgraded):focus .mdc-radio__focus-ring{pointer-events:none;border:2px solid transparent;border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:100%;width:100%}@media screen and (forced-colors: active){.mdc-radio.mdc-ripple-upgraded--background-focused .mdc-radio__focus-ring,.mdc-radio:not(.mdc-ripple-upgraded):focus .mdc-radio__focus-ring{border-color:CanvasText}}.mdc-radio.mdc-ripple-upgraded--background-focused .mdc-radio__focus-ring::after,.mdc-radio:not(.mdc-ripple-upgraded):focus .mdc-radio__focus-ring::after{content:"";border:2px solid transparent;border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-radio.mdc-ripple-upgraded--background-focused .mdc-radio__focus-ring::after,.mdc-radio:not(.mdc-ripple-upgraded):focus .mdc-radio__focus-ring::after{border-color:CanvasText}}.mdc-radio__native-control:checked+.mdc-radio__background,.mdc-radio__native-control:disabled+.mdc-radio__background{transition:opacity 120ms 0ms cubic-bezier(0, 0, 0.2, 1),transform 120ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__outer-circle,.mdc-radio__native-control:disabled+.mdc-radio__background .mdc-radio__outer-circle{transition:border-color 120ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__inner-circle,.mdc-radio__native-control:disabled+.mdc-radio__background .mdc-radio__inner-circle{transition:transform 120ms 0ms cubic-bezier(0, 0, 0.2, 1),border-color 120ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-radio--disabled{cursor:default;pointer-events:none}.mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__inner-circle{transform:scale(0.5);transition:transform 120ms 0ms cubic-bezier(0, 0, 0.2, 1),border-color 120ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-radio__native-control:disabled+.mdc-radio__background,[aria-disabled=true] .mdc-radio__native-control+.mdc-radio__background{cursor:default}.mdc-radio__native-control:focus+.mdc-radio__background::before{transform:scale(1);opacity:.12;transition:opacity 120ms 0ms cubic-bezier(0, 0, 0.2, 1),transform 120ms 0ms cubic-bezier(0, 0, 0.2, 1)}:host{display:inline-block;outline:none}.mdc-radio{vertical-align:bottom}.mdc-radio .mdc-radio__native-control:enabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-unchecked-color, rgba(0, 0, 0, 0.54))}.mdc-radio [aria-disabled=true] .mdc-radio__native-control:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle,.mdc-radio .mdc-radio__native-control:disabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-disabled-color, rgba(0, 0, 0, 0.38))}.mdc-radio [aria-disabled=true] .mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__outer-circle,.mdc-radio .mdc-radio__native-control:disabled:checked+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-disabled-color, rgba(0, 0, 0, 0.38))}.mdc-radio [aria-disabled=true] .mdc-radio__native-control+.mdc-radio__background .mdc-radio__inner-circle,.mdc-radio .mdc-radio__native-control:disabled+.mdc-radio__background .mdc-radio__inner-circle{border-color:var(--mdc-radio-disabled-color, rgba(0, 0, 0, 0.38))}`;

// ../node_modules/@material/mwc-radio/mwc-radio.js
var Radio = class Radio2 extends RadioBase {
};
Radio.styles = [styles];
Radio = __decorate([
  customElement("mwc-radio")
], Radio);
export {
  Radio,
  SingleSelectionController
};
/*! Bundled license information:

@material/mwc-radio/single-selection-controller.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

@material/radio/constants.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/radio/foundation.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/mwc-radio/mwc-radio-base.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

@material/mwc-radio/mwc-radio.css.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-LIcense-Identifier: Apache-2.0
   *)

@material/mwc-radio/mwc-radio.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=@material_mwc-radio.js.map
